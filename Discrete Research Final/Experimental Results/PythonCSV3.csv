,,,,def,stopBuild(self,,reason="<no,reason,given>"):,,,,,,,,,,
#,the,idea,here,is,to,let,the,user,cancel,a,build,because,,e.g.,
#,they,realized,they,committed,a,bug,and,they,don't,want,to,waste
#,the,time,building,something,that,they,know,will,fail.,Another
#,reason,might,be,to,abandon,a,stuck,build.,We,want,to,mark,the
#,build,as,failed,quickly,rather,than,waiting,for,the,slave's
#,timeout,to,kill,it,on,its,own.
log.msg(",%s:,stopping,build:,%s",%,(self,,reason))
if,self.finished:
return
#,TODO:,include,'reason',in,this,point,event
self.builder.builder_status.addPointEvent(['interrupt'])
self.currentStep.interrupt(reason)
self.steps,=,[]
if,0:
#,TODO:,maybe,let,its,deferred,do,buildFinished
if,self.currentStep,and,self.currentStep.progress:
#,XXX:,really,.fail,or,something
self.currentStep.progress.finish()
text,=,["stopped",,reason]
self.buildFinished(text,,FAILURE)
def,allStepsDone(self):
if,self.result,==,FAILURE:
text,=,["failed"]
elif,self.result,==,WARNINGS:
text,=,["warnings"]
elif,self.result,==,EXCEPTION:
text,=,["exception"]
else:
text,=,["build",,"successful"]
text.extend(self.text)
return,self.buildFinished(text,,self.result)
def,buildException(self,,why):
log.msg("%s.buildException",%,self)
log.err(why)
self.buildFinished(["build",,"exception"],,FAILURE)
def,buildFinished(self,,text,,results):
"""This,method,must,be,called,when,the,last,Step,has,completed.,It
marks,the,Build,as,complete,and,returns,the,Builder,to,the,'idle'
state.
It,takes,two,arguments,which,describe,the,overall,build,status:
text,,results.,'results',is,one,of,SUCCESS,,WARNINGS,,or,FAILURE.
If,'results',is,SUCCESS,or,WARNINGS,,we,will,permit,any,dependant
builds,to,start.,If,it,is,'FAILURE',,those,builds,will,be
abandoned."""
self.finished,=,True
if,self.remote:
self.remote.dontNotifyOnDisconnect(self.lostRemote)
self.results,=,results
log.msg(",%s:,build,finished",%,self)
self.build_status.setText(text)
self.build_status.setResults(results)
self.build_status.buildFinished()
if,self.progress,and,results,==,SUCCESS:
#,XXX:,also,test,a,'timing,consistent',flag?
log.msg(",setting,expectations,for,next,time")
self.builder.setExpectations(self.progress)
reactor.callLater(0,,self.releaseLocks)
self.deferred.callback(self)
self.deferred,=,None
def,releaseLocks(self):
log.msg("releaseLocks(%s):,%s",%,(self,,self.locks))
for,lock,,access,in,self.locks:
lock.release(self,,access)
#,IBuildControl
def,getStatus(self):
return,self.build_status
#,stopBuild,is,defined,earlier
#,-*-,test-case-name:,buildbot.test.test_slavecommand,-*-
#,This,Source,Code,Form,is,subject,to,the,terms,of,the,Mozilla,Public
#,License,,v.,2.0.,If,a,copy,of,the,MPL,was,not,distributed,with,this
#,file,,You,can,obtain,one,at,http://mozilla.org/MPL/2.0/.
import,os,,re,,signal,,shutil,,types,,time
from,stat,import,ST_CTIME,,ST_MTIME,,ST_SIZE
from,zope.interface,import,implements
from,twisted.internet.protocol,import,ProcessProtocol
from,twisted.internet,import,reactor,,defer,,task
from,twisted.python,import,log,,failure,,runtime
from,twisted.python.procutils,import,which
from,buildbot.slave.interfaces,import,ISlaveCommand
from,buildbot.slave.registry,import,registerSlaveCommand
#,this,used,to,be,a,CVS,$-style,"Revision",auto-updated,keyword,,but,since,I
#,moved,to,Darcs,as,the,primary,repository,,this,is,updated,manually,each
#,time,this,file,is,changed.,The,last,cvs_ver,that,was,here,was,1.51,.
command_version,=,"2.8"
#,version,history:
#,,>=1.17:,commands,are,interruptable
#,,>=1.28:,Arch,understands,'revision',,added,Bazaar
#,,>=1.33:,Source,classes,understand,'retry'
#,,>=1.39:,Source,classes,correctly,handle,changes,in,branch,(except,Git)
#,,,,,,,,,,Darcs,accepts,'revision',(now,all,do,but,Git),(well,,and,P4Sync)
#,,,,,,,,,,Arch/Baz,should,accept,'build-config'
#,,>=1.51:,(release,0.7.3)
#,,>=,2.1:,SlaveShellCommand,now,accepts,'initial_stdin',,'keep_stdin_open',
#,,,,,,,,,,and,'logfiles'.,It,now,sends,'log',messages,in,addition,to
#,,,,,,,,,,stdout/stdin/header/rc.,It,acquired,writeStdin/closeStdin,methods,
#,,,,,,,,,,but,these,are,not,remotely,callable,yet.
#,,,,,,,,,,(not,externally,visible:,ShellCommandPP,has,writeStdin/closeStdin.
#,,,,,,,,,,ShellCommand,accepts,new,arguments,(logfiles=,,initialStdin=,
#,,,,,,,,,,keepStdinOpen=),and,no,longer,accepts,stdin=)
#,,,,,,,,,,(release,0.7.4)
#,,>=,2.2:,added,monotone,,uploadFile,,and,downloadFile,(release,0.7.5)
#,,>=,2.3:,added,bzr,(release,0.7.6)
#,,>=,2.4:,Git,understands,'revision',and,branches
#,,>=,2.5:,workaround,added,for,remote,'hg,clone,--rev,REV',when,hg<0.9.2
#,,>=,2.6:,added,uploadDirectory
#,,>=,2.7:,added,usePTY,option,to,SlaveShellCommand
#,,>=,2.8:,added,username,and,password,args,to,SVN,class
class,CommandInterrupted(Exception):
pass
class,TimeoutError(Exception):
pass
class,Obfuscated:
"""An,obfuscated,string,in,a,command"""
def,__init__(self,,real,,fake):
self.real,=,real
self.fake,=,fake
def,__str__(self):
return,self.fake
def,__repr__(self):
return,`self.fake`
def,get_real(command):
rv,=,command
if,type(command),==,types.ListType:
rv,=,[]
for,elt,in,command:
if,isinstance(elt,,Obfuscated):
rv.append(elt.real)
else:
rv.append(elt)
return,rv
get_real,=,staticmethod(get_real)
def,get_fake(command):
rv,=,command
if,type(command),==,types.ListType:
rv,=,[]
for,elt,in,command:
if,isinstance(elt,,Obfuscated):
rv.append(elt.fake)
else:
rv.append(elt)
return,rv
get_fake,=,staticmethod(get_fake)
class,AbandonChain(Exception):
"""A,series,of,chained,steps,can,raise,this,exception,to,indicate,that
one,of,the,intermediate,ShellCommands,has,failed,,such,that,there,is,no
point,in,running,the,remainder.,'rc',should,be,the,non-zero,exit,code,of
the,failing,ShellCommand."""
def,__repr__(self):
return,"<AbandonChain,rc=%s>",%,self.args[0]
def,getCommand(name):
possibles,=,which(name)
if,not,possibles:
raise,RuntimeError("Couldn't,find,executable,for,'%s'",%,name)
return,possibles[0]
def,rmdirRecursive(dir):
"""This,is,a,replacement,for,shutil.rmtree,that,works,better,under
windows.,Thanks,to,Bear,at,the,OSAF,for,the,code."""
if,not,os.path.exists(dir):
return
if,os.path.islink(dir):
os.remove(dir)
return
#,Verify,the,directory,is,read/write/execute,for,the,current,user
os.chmod(dir,,0700)
for,name,in,os.listdir(dir):
full_name,=,os.path.join(dir,,name)
#,on,Windows,,if,we,don't,have,write,permission,we,can't,remove
#,the,file/directory,either,,so,turn,that,on
if,os.name,==,'nt':
if,not,os.access(full_name,,os.W_OK):
#,I,think,this,is,now,redundant,,but,I,don't,have,an,NT
#,machine,to,test,on,,so,I'm,going,to,leave,it,in,place
#,-warner
os.chmod(full_name,,0600)
if,os.path.isdir(full_name):
rmdirRecursive(full_name)
else:
os.chmod(full_name,,0700)
os.remove(full_name)
os.rmdir(dir)
class,ShellCommandPP(ProcessProtocol):
debug,=,False
def,__init__(self,,command):
self.command,=,command
self.pending_stdin,=,""
self.stdin_finished,=,False
def,writeStdin(self,,data):
assert,not,self.stdin_finished
if,self.connected:
self.transport.write(data)
else:
self.pending_stdin,+=,data
def,closeStdin(self):
if,self.connected:
if,self.debug:,log.msg(",closing,stdin")
self.transport.closeStdin()
self.stdin_finished,=,True
def,connectionMade(self):
if,self.debug:
log.msg("ShellCommandPP.connectionMade")
if,not,self.command.process:
if,self.debug:
log.msg(",assigning,self.command.process:,%s",%
(self.transport,))
self.command.process,=,self.transport
#,TODO:,maybe,we,shouldn't,close,stdin,when,using,a,PTY.,I,can't,test
#,this,yet,,recent,debian,glibc,has,a,bug,which,causes,thread-using
#,test,cases,to,SIGHUP,trial,,and,the,workaround,is,to,either,run
#,the,whole,test,with,/bin/sh,-c,",".join(argv),,(way,gross),or,to
#,not,use,a,PTY.,Once,the,bug,is,fixed,,I'll,be,able,to,test,what
#,happens,when,you,close,stdin,on,a,pty.,My,concern,is,that,it,will
#,SIGHUP,the,child,(since,we,are,,in,a,sense,,hanging,up,on,them).
#,But,it,may,well,be,that,keeping,stdout,open,prevents,the,SIGHUP
#,from,being,sent.
#if,not,self.command.usePTY:
if,self.pending_stdin:
if,self.debug:,log.msg(",writing,to,stdin")
self.transport.write(self.pending_stdin)
if,self.stdin_finished:
if,self.debug:,log.msg(",closing,stdin")
self.transport.closeStdin()
def,outReceived(self,,data):
if,self.debug:
log.msg("ShellCommandPP.outReceived")
self.command.addStdout(data)
def,errReceived(self,,data):
if,self.debug:
log.msg("ShellCommandPP.errReceived")
self.command.addStderr(data)
def,processEnded(self,,status_object):
if,self.debug:
log.msg("ShellCommandPP.processEnded",,status_object)
#,status_object,is,a,Failure,wrapped,around,an
#,error.ProcessTerminated,or,and,error.ProcessDone.
#,requires,twisted,>=,1.0.4,to,overcome,a,bug,in,process.py
sig,=,status_object.value.signal
rc,=,status_object.value.exitCode
self.command.finished(sig,,rc)
class,LogFileWatcher:
POLL_INTERVAL,=,2
def,__init__(self,,command,,name,,logfile):
self.command,=,command
self.name,=,name
self.logfile,=,logfile
log.msg("LogFileWatcher,created,to,watch,%s",%,logfile)
#,we,are,created,before,the,ShellCommand,starts.,If,the,logfile,we're
#,supposed,to,be,watching,already,exists,,record,its,size,and
#,ctime/mtime,so,we,can,tell,when,it,starts,to,change.
self.old_logfile_stats,=,self.statFile()
self.started,=,False
#,every,2,seconds,we,check,on,the,file,again
self.poller,=,task.LoopingCall(self.poll)
def,start(self):
self.poller.start(self.POLL_INTERVAL).addErrback(self._cleanupPoll)
def,_cleanupPoll(self,,err):
log.err(err,,msg="Polling,error")
self.poller,=,None
def,stop(self):
self.poll()
if,self.poller,is,not,None:
self.poller.stop()
if,self.started:
self.f.close()
def,statFile(self):
if,os.path.exists(self.logfile):
s,=,os.stat(self.logfile)
return,(s[ST_CTIME],,s[ST_MTIME],,s[ST_SIZE])
return,None
def,poll(self):
if,not,self.started:
s,=,self.statFile()
if,s,==,self.old_logfile_stats:
return,#,not,started,yet
if,not,s:
#,the,file,was,there,,but,now,it's,deleted.,Forget,about,the
#,initial,state,,clearly,the,process,has,deleted,the,logfile
#,in,preparation,for,creating,a,new,one.
self.old_logfile_stats,=,None
return,#,no,file,to,work,with
self.f,=,open(self.logfile,,"rb")
self.started,=,True
self.f.seek(self.f.tell(),,0)
while,True:
data,=,self.f.read(10000)
if,not,data:
return
self.command.addLogfile(self.name,,data)
class,ShellCommand:
#,This,is,a,helper,class,,used,by,SlaveCommands,to,run,programs,in,a
#,child,shell.
notreally,=,False
BACKUP_TIMEOUT,=,5
KILL,=,"KILL"
CHUNK_LIMIT,=,128*1024
#,For,sending,elapsed,time:
startTime,=,None
elapsedTime,=,None
#,I,wish,we,had,easy,access,to,CLOCK_MONOTONIC,in,Python:
#,http://www.opengroup.org/onlinepubs/000095399/functions/clock_getres.html
#,Then,changes,to,the,system,clock,during,a,run,wouldn't,effect,the,"elapsed
#,time",results.
def,__init__(self,,builder,,command,
workdir,,environ=None,
sendStdout=True,,sendStderr=True,,sendRC=True,
timeout=None,,initialStdin=None,,keepStdinOpen=False,
keepStdout=False,,keepStderr=False,,logEnviron=False,
logfiles={},,usePTY="slave-config"):
"""
@param,keepStdout:,if,True,,we,keep,a,copy,of,all,the,stdout,text
that,we've,seen.,This,copy,is,available,in
self.stdout,,which,can,be,read,after,the,command
has,finished.
@param,keepStderr:,same,,for,stderr
@param,usePTY:,"slave-config",->,use,the,SlaveBuilder's,usePTY,;
otherwise,,true,to,use,a,PTY,,false,to,not,use,a,PTY.
"""
self.builder,=,builder
self.command,=,Obfuscated.get_real(command)
self.fake_command,=,Obfuscated.get_fake(command)
self.sendStdout,=,sendStdout
self.sendStderr,=,sendStderr
self.sendRC,=,sendRC
self.logfiles,=,logfiles
self.workdir,=,workdir
self.environ,=,os.environ.copy()
if,environ:
if,environ.has_key('PYTHONPATH'):
ppath,=,environ['PYTHONPATH']
#,Need,to,do,os.pathsep,translation.,,We,could,either,do,that
#,by,replacing,all,incoming,':'s,with,os.pathsep,,or,by
#,accepting,lists.,,I,like,lists,better.
if,not,isinstance(ppath,,str):
#,If,it's,not,a,string,,treat,it,as,a,sequence,to,be
#,turned,in,to,a,string.
ppath,=,os.pathsep.join(ppath)
if,self.environ.has_key('PYTHONPATH'):
#,special,case,,prepend,the,builder's,items,to,the
#,existing,ones.,This,will,break,if,you,send,over,empty
#,strings,,so,don't,do,that.
ppath,=,ppath,+,os.pathsep,+,self.environ['PYTHONPATH']
environ['PYTHONPATH'],=,ppath
self.environ.update(environ)
self.initialStdin,=,initialStdin
self.keepStdinOpen,=,keepStdinOpen
self.logEnviron,=,logEnviron
self.timeout,=,timeout
self.timer,=,None
self.keepStdout,=,keepStdout
self.keepStderr,=,keepStderr
if,usePTY,==,"slave-config":
self.usePTY,=,self.builder.usePTY
else:
self.usePTY,=,usePTY
#,usePTY=True,is,a,convenience,for,cleaning,up,all,children,and
#,grandchildren,of,a,hung,command.,Fall,back,to,usePTY=False,on,systems
#,and,in,situations,where,ptys,cause,problems.,,PTYs,are,posix-only,
#,and,for,.closeStdin,to,matter,,we,must,use,a,pipe,,not,a,PTY
if,runtime.platformType,!=,"posix",or,initialStdin,is,not,None:
if,self.usePTY,and,usePTY,!=,"slave-config":
self.sendStatus({'header':,"WARNING:,disabling,usePTY,for,this,command"})
self.usePTY,=,False
self.logFileWatchers,=,[]
for,name,filename,in,self.logfiles.items():
w,=,LogFileWatcher(self,,name,
os.path.join(self.workdir,,filename))
self.logFileWatchers.append(w)
def,__repr__(self):
return,"<slavecommand.ShellCommand,'%s'>",%,self.fake_command
def,sendStatus(self,,status):
self.builder.sendUpdate(status)
def,start(self):
#,return,a,Deferred,which,fires,(with,the,exit,code),when,the,command
#,completes
if,self.keepStdout:
self.stdout,=,""
if,self.keepStderr:
self.stderr,=,""
self.deferred,=,defer.Deferred()
try:
self._startCommand()
except:
log.msg("error,in,ShellCommand._startCommand")
log.err()
#,pretend,it,was,a,shell,error
self.deferred.errback(AbandonChain(-1))
return,self.deferred
def,_startCommand(self):
#,ensure,workdir,exists
if,not,os.path.isdir(self.workdir):
os.makedirs(self.workdir)
log.msg("ShellCommand._startCommand")
if,self.notreally:
self.sendStatus({'header':,"command,'%s',in,dir,%s",%,\
(self.fake_command,,self.workdir)})
self.sendStatus({'header':,"(not,really)\n"})
self.finished(None,,0)
return
self.pp,=,ShellCommandPP(self)
if,type(self.command),in,types.StringTypes:
if,runtime.platformType,,==,'win32':
argv,=,os.environ['COMSPEC'].split(),#,allow,%COMSPEC%,to,have,args
if,'/c',not,in,argv:,argv,+=,['/c'],
argv,+=,[self.command]
else:
#,for,posix,,use,/bin/sh.,for,other,non-posix,,well,,doesn't
#,hurt,to,try
argv,=,['/bin/sh',,'-c',,self.command]
display,=,self.fake_command
else:
if,runtime.platformType,,==,'win32':
argv,=,os.environ['COMSPEC'].split(),#,allow,%COMSPEC%,to,have,args
if,'/c',not,in,argv:,argv,+=,['/c'],
argv,+=,list(self.command)
else:
argv,=,self.command
display,=,",".join(self.fake_command)
#,$PWD,usually,indicates,the,current,directory,;,spawnProcess,may,not
#,update,this,value,,though,,so,we,set,it,explicitly,here.
self.environ['PWD'],=,os.path.abspath(self.workdir)
#,self.stdin,is,handled,in,ShellCommandPP.connectionMade
#,first,header,line,is,the,command,in,plain,text,,argv,joined,with
#,spaces.,You,should,be,able,to,cut-and-paste,this,into,a,shell,to
#,obtain,the,same,results.,If,there,are,spaces,in,the,arguments,,too
#,bad.
log.msg(",",+,display)
self.sendStatus({'header':,display+"\n"})
#,then,comes,the,secondary,information
msg,=,",in,dir,%s",%,(self.workdir,)
if,self.timeout:
msg,+=,",(timeout,%d,secs)",%,(self.timeout,)
log.msg(",",+,msg)
self.sendStatus({'header':,msg+"\n"})
msg,=,",watching,logfiles,%s",%,(self.logfiles,)
log.msg(",",+,msg)
self.sendStatus({'header':,msg+"\n"})
#,then,the,obfuscated,command,array,for,resolving,unambiguity
msg,=,",argv:,%s",%,(self.fake_command,)
log.msg(",",+,msg)
self.sendStatus({'header':,msg+"\n"})
#,then,the,environment,,since,it,sometimes,causes,problems
if,self.logEnviron:
msg,=,",environment:\n"
env_names,=,self.environ.keys()
env_names.sort()
for,name,in,env_names:
msg,+=,",,%s=%s\n",%,(name,,self.environ[name])
log.msg(",environment:,%s",%,(self.environ,))
self.sendStatus({'header':,msg})
if,self.initialStdin:
msg,=,",writing,%d,bytes,to,stdin",%,len(self.initialStdin)
log.msg(",",+,msg)
self.sendStatus({'header':,msg+"\n"})
if,self.keepStdinOpen:
msg,=,",leaving,stdin,open"
else:
msg,=,",closing,stdin"
log.msg(",",+,msg)
self.sendStatus({'header':,msg+"\n"})
msg,=,",using,PTY:,%s",%,bool(self.usePTY)
log.msg(",",+,msg)
self.sendStatus({'header':,msg+"\n"})
#,this,will,be,buffered,until,connectionMade,is,called
if,self.initialStdin:
self.pp.writeStdin(self.initialStdin)
if,not,self.keepStdinOpen:
self.pp.closeStdin()
#,win32eventreactor's,spawnProcess,(under,twisted,<=,2.0.1),returns
#,None,,as,opposed,to,all,the,posixbase-derived,reactors,(which
#,return,the,new,Process,object).,This,is,a,nuisance.,We,can,make,up
#,for,it,by,having,the,ProcessProtocol,give,us,their,.transport
#,attribute,after,they,get,one.,I'd,prefer,to,get,it,from
#,spawnProcess,because,I'm,concerned,about,returning,from,this,method
#,without,having,a,valid,self.process,to,work,with.,(if,kill(),were
#,called,right,after,we,return,,but,somehow,before,connectionMade
#,were,called,,then,kill(),would,blow,up).
self.process,=,None
self.startTime,=,time.time()
p,=,reactor.spawnProcess(self.pp,,argv[0],,argv,
self.environ,
self.workdir,
usePTY=self.usePTY)
#,connectionMade,might,have,been,called,during,spawnProcess
if,not,self.process:
self.process,=,p
#,connectionMade,also,closes,stdin,as,long,as,we're,not,using,a,PTY.
#,This,is,intended,to,kill,off,inappropriately,interactive,commands
#,better,than,the,(long),hung-command,timeout.,ProcessPTY,should,be
#,enhanced,to,allow,the,same,childFDs,argument,that,Process,takes,
#,which,would,let,us,connect,stdin,to,/dev/null,.
if,self.timeout:
self.timer,=,reactor.callLater(self.timeout,,self.doTimeout)
for,w,in,self.logFileWatchers:
w.start()
def,_chunkForSend(self,,data):
#,limit,the,chunks,that,we,send,over,PB,to,128k,,since,it,has,a
#,hardwired,string-size,limit,of,640k.
LIMIT,=,self.CHUNK_LIMIT
for,i,in,range(0,,len(data),,LIMIT):
yield,data[i:i+LIMIT]
def,addStdout(self,,data):
if,self.sendStdout:
for,chunk,in,self._chunkForSend(data):
self.sendStatus({'stdout':,chunk})
if,self.keepStdout:
self.stdout,+=,data
if,self.timer:
self.timer.reset(self.timeout)
def,addStderr(self,,data):
if,self.sendStderr:
for,chunk,in,self._chunkForSend(data):
self.sendStatus({'stderr':,chunk})
if,self.keepStderr:
self.stderr,+=,data
if,self.timer:
self.timer.reset(self.timeout)
def,addLogfile(self,,name,,data):
for,chunk,in,self._chunkForSend(data):
self.sendStatus({'log':,(name,,chunk)})
if,self.timer:
self.timer.reset(self.timeout)
def,finished(self,,sig,,rc):
self.elapsedTime,=,time.time(),-,self.startTime
log.msg("command,finished,with,signal,%s,,exit,code,%s,,elapsedTime:,%0.6f",%,(sig,rc,self.elapsedTime))
for,w,in,self.logFileWatchers:
#,this,will,send,the,final,updates
w.stop()
if,sig,is,not,None:
rc,=,-1
if,self.sendRC:
if,sig,is,not,None:
self.sendStatus(
{'header':,"process,killed,by,signal,%d\n",%,sig})
self.sendStatus({'rc':,rc})
self.sendStatus({'header':,"elapsedTime=%0.6f\n",%,self.elapsedTime})
if,self.timer:
self.timer.cancel()
self.timer,=,None
d,=,self.deferred
self.deferred,=,None
if,d:
d.callback(rc)
else:
log.msg("Hey,,command,%s,finished,twice",%,self)
def,failed(self,,why):
log.msg("ShellCommand.failed:,command,failed:,%s",%,(why,))
if,self.timer:
self.timer.cancel()
self.timer,=,None
d,=,self.deferred
self.deferred,=,None
if,d:
d.errback(why)
else:
log.msg("Hey,,command,%s,finished,twice",%,self)
def,doTimeout(self):
self.timer,=,None
msg,=,"command,timed,out:,%d,seconds,without,output",%,self.timeout
self.kill(msg)
def,kill(self,,msg):
#,This,may,be,called,by,the,timeout,,or,when,the,user,has,decided,to
#,abort,this,build.
if,self.timer:
self.timer.cancel()
self.timer,=,None
if,hasattr(self.process,,"pid"):
msg,+=,",,killing,pid,%d",%,self.process.pid
log.msg(msg)
self.sendStatus({'header':,"\n",+,msg,+,"\n"})
hit,=,0
if,runtime.platformType,==,"posix":
try:
#,really,want,to,kill,off,all,child,processes,too.,Process
#,Groups,are,ideal,for,this,,but,that,requires
#,spawnProcess(usePTY=1).,Try,both,ways,in,case,process,was
#,not,started,that,way.
#,the,test,suite,sets,self.KILL=None,to,tell,us,we,should
#,only,pretend,to,kill,the,child.,This,lets,us,test,the
#,backup,timer.
sig,=,None
if,self.KILL,is,not,None:
sig,=,getattr(signal,,"SIG"+,self.KILL,,None)
if,self.KILL,==,None:
log.msg("self.KILL==None,,only,pretending,to,kill,child")
elif,sig,is,None:
log.msg("signal,module,is,missing,SIG%s",%,self.KILL)
elif,not,hasattr(os,,"kill"):
log.msg("os,module,is,missing,the,'kill',function")
else:
log.msg("trying,os.kill(-pid,,%d)",%,(sig,))
#,TODO:,maybe,use,os.killpg,instead,of,a,negative,pid?
os.kill(-self.process.pid,,sig)
log.msg(",signal,%s,sent,successfully",%,sig)
hit,=,1
except,OSError:
#,probably,no-such-process,,maybe,because,there,is,no,process
#,group
pass
if,not,hit:
try:
if,self.KILL,is,None:
log.msg("self.KILL==None,,only,pretending,to,kill,child")
else:
log.msg("trying,process.signalProcess('KILL')")
self.process.signalProcess(self.KILL)
log.msg(",signal,%s,sent,successfully",%,(self.KILL,))
hit,=,1
except,OSError:
#,could,be,no-such-process,,because,they,finished,very,recently
pass
if,not,hit:
log.msg("signalProcess/os.kill,failed,both,times")
if,runtime.platformType,==,"posix":
#,we,only,do,this,under,posix,because,the,win32eventreactor
#,blocks,here,until,the,process,has,terminated,,while,closing
#,stderr.,This,is,weird.
self.pp.transport.loseConnection()
#,finished,ought,to,be,called,momentarily.,Just,in,case,it,doesn't,
#,set,a,timer,which,will,abandon,the,command.
self.timer,=,reactor.callLater(self.BACKUP_TIMEOUT,
self.doBackupTimeout)
def,doBackupTimeout(self):
log.msg("we,tried,to,kill,the,process,,and,it,wouldn't,die.."
",finish,anyway")
self.timer,=,None
self.sendStatus({'header':,"SIGKILL,failed,to,kill,process\n"})
if,self.sendRC:
self.sendStatus({'header':,"using,fake,rc=-1\n"})
self.sendStatus({'rc':,-1})
self.failed(TimeoutError("SIGKILL,failed,to,kill,process"))
def,writeStdin(self,,data):
self.pp.writeStdin(data)
def,closeStdin(self):
self.pp.closeStdin()
class,Command:
implements(ISlaveCommand)
"""This,class,defines,one,command,that,can,be,invoked,by,the,build,master.
The,command,is,executed,on,the,slave,side,,and,always,sends,back,a
completion,message,when,it,finishes.,It,may,also,send,intermediate,status
as,it,runs,(by,calling,builder.sendStatus).,Some,commands,can,be
interrupted,(either,by,the,build,master,or,a,local,timeout),,in,which
case,the,step,is,expected,to,complete,normally,with,a,status,message,that
indicates,an,error,occurred.
These,commands,are,used,by,BuildSteps,on,the,master,side.,Each,kind,of
BuildStep,uses,a,single,Command.,The,slave,must,implement,all,the
Commands,required,by,the,set,of,BuildSteps,used,for,any,given,build:
this,is,checked,at,startup,time.
All,Commands,are,constructed,with,the,same,signature:
c,=,CommandClass(builder,,args)
where,'builder',is,the,parent,SlaveBuilder,object,,and,'args',is,a
dict,that,is,interpreted,per-command.
The,setup(args),method,is,available,for,setup,,and,is,run,from,__init__.
The,Command,is,started,with,start().,This,method,must,be,implemented,in,a
subclass,,and,it,should,return,a,Deferred.,When,your,step,is,done,,you
should,fire,the,Deferred,(the,results,are,not,used).,If,the,command,is
interrupted,,it,should,fire,the,Deferred,anyway.
While,the,command,runs.,it,may,send,status,messages,back,to,the
buildmaster,by,calling,self.sendStatus(statusdict).,The,statusdict,is
interpreted,by,the,master-side,BuildStep,however,it,likes.
A,separate,completion,message,is,sent,when,the,deferred,fires,,which
indicates,that,the,Command,has,finished,,but,does,not,carry,any,status
data.,If,the,Command,needs,to,return,an,exit,code,of,some,sort,,that
should,be,sent,as,a,regular,status,message,before,the,deferred,is,fired,.
Once,builder.commandComplete,has,been,run,,no,more,status,messages,may,be
sent.
If,interrupt(),is,called,,the,Command,should,attempt,to,shut,down,as
quickly,as,possible.,Child,processes,should,be,killed,,new,ones,should
not,be,started.,The,Command,should,send,some,kind,of,error,status,update,
then,complete,as,usual,by,firing,the,Deferred.
.interrupted,should,be,set,by,interrupt(),,and,can,be,tested,to,avoid
sending,multiple,error,status,messages.
If,.running,is,False,,the,bot,is,shutting,down,(or,has,otherwise,lost,the
connection,to,the,master),,and,should,not,send,any,status,messages.,This
is,checked,in,Command.sendStatus,.
"""
#,builder,methods:
#,,sendStatus(dict),(zero,or,more)
#,,commandComplete(),or,commandInterrupted(),(one,,at,end)
debug,=,False
interrupted,=,False
running,=,False,#,set,by,Builder,,cleared,on,shutdown,or,when,the
#,Deferred,fires
def,__init__(self,,builder,,stepId,,args):
self.builder,=,builder
self.stepId,=,stepId,#,just,for,logging
self.args,=,args
self.setup(args)
def,setup(self,,args):
"""Override,this,in,a,subclass,to,extract,items,from,the,args,dict."""
pass
def,doStart(self):
self.running,=,True
d,=,defer.maybeDeferred(self.start)
d.addBoth(self.commandComplete)
return,d
def,start(self):
"""Start,the,command.,This,method,should,return,a,Deferred,that,will
fire,when,the,command,has,completed.,The,Deferred's,argument,will,be
ignored.
This,method,should,be,overridden,by,subclasses."""
raise,NotImplementedError,,"You,must,implement,this,in,a,subclass"
def,sendStatus(self,,status):
"""Send,a,status,update,to,the,master."""
if,self.debug:
log.msg("sendStatus",,status)
if,not,self.running:
log.msg("would,sendStatus,but,not,.running")
return
self.builder.sendUpdate(status)
def,doInterrupt(self):
self.running,=,False
self.interrupt()
def,interrupt(self):
"""Override,this,in,a,subclass,to,allow,commands,to,be,interrupted.
May,be,called,multiple,times,,test,and,set,self.interrupted=True,if
this,matters."""
pass
def,commandComplete(self,,res):
self.running,=,False
return,res
#,utility,methods,,mostly,used,by,SlaveShellCommand,and,the,like
def,_abandonOnFailure(self,,rc):
if,type(rc),is,not,int:
log.msg("weird,,_abandonOnFailure,was,given,rc=%s,(%s)",%,\
(rc,,type(rc)))
assert,isinstance(rc,,int)
if,rc,!=,0:
raise,AbandonChain(rc)
return,rc
def,_sendRC(self,,res):
self.sendStatus({'rc':,0})
def,_checkAbandoned(self,,why):
log.msg("_checkAbandoned",,why)
why.trap(AbandonChain)
log.msg(",abandoning,chain",,why.value)
self.sendStatus({'rc':,why.value.args[0]})
return,None
class,SlaveFileUploadCommand(Command):
"""
Upload,a,file,from,slave,to,build,master
Arguments:
-,['workdir']:,,,base,directory,to,use
-,['slavesrc']:,,name,of,the,slave-side,file,to,read,from
-,['writer']:,,,,RemoteReference,to,a,transfer._FileWriter,object
-,['maxsize']:,,,max,size,(in,bytes),of,file,to,write
-,['blocksize']:,max,size,for,each,data,block
"""
debug,=,False
def,setup(self,,args):
self.workdir,=,args['workdir']
self.filename,=,args['slavesrc']
self.writer,=,args['writer']
self.remaining,=,args['maxsize']
self.blocksize,=,args['blocksize']
self.stderr,=,None
self.rc,=,0
def,start(self):
if,self.debug:
log.msg('SlaveFileUploadCommand,started')
#,Open,file
self.path,=,os.path.join(self.builder.basedir,
self.workdir,
os.path.expanduser(self.filename))
try:
self.fp,=,open(self.path,,'rb')
if,self.debug:
log.msg('Opened,%r,for,upload',%,self.path)
except:
#,TODO:,this,needs,cleanup
self.fp,=,None
self.stderr,=,'Cannot,open,file,%r,for,upload',%,self.path
self.rc,=,1
if,self.debug:
log.msg('Cannot,open,file,%r,for,upload',%,self.path)
self.sendStatus({'header':,"sending,%s",%,self.path})
d,=,defer.Deferred()
reactor.callLater(0,,self._loop,,d)
def,_close(res):
#,close,the,file,,but,pass,through,any,errors,from,_loop
d1,=,self.writer.callRemote("close")
d1.addErrback(log.err)
d1.addCallback(lambda,ignored:,res)
return,d1
d.addBoth(_close)
d.addBoth(self.finished)
return,d
def,_loop(self,,fire_when_done):
d,=,defer.maybeDeferred(self._writeBlock)
def,_done(finished):
if,finished:
fire_when_done.callback(None)
else:
self._loop(fire_when_done)
def,_err(why):
fire_when_done.errback(why)
d.addCallbacks(_done,,_err)
return,None
def,_writeBlock(self):
"""Write,a,block,of,data,to,the,remote,writer"""
if,self.interrupted,or,self.fp,is,None:
if,self.debug:
log.msg('SlaveFileUploadCommand._writeBlock():,end')
return,True
length,=,self.blocksize
if,self.remaining,is,not,None,and,length,>,self.remaining:
length,=,self.remaining
if,length,<=,0:
if,self.stderr,is,None:
self.stderr,=,'Maximum,filesize,reached,,truncating,file,%r',\
%,self.path
self.rc,=,1
data,=,''
else:
data,=,self.fp.read(length)
if,self.debug:
log.msg('SlaveFileUploadCommand._writeBlock():,'+
'allowed=%d,readlen=%d',%,(length,,len(data)))
if,len(data),==,0:
log.msg("EOF:,callRemote(close)")
return,True
if,self.remaining,is,not,None:
self.remaining,=,self.remaining,-,len(data)
assert,self.remaining,>=,0
d,=,self.writer.callRemote('write',,data)
d.addCallback(lambda,res:,False)
return,d
def,interrupt(self):
if,self.debug:
log.msg('interrupted')
if,self.interrupted:
return
if,self.stderr,is,None:
self.stderr,=,'Upload,of,%r,interrupted',%,self.path
self.rc,=,1
self.interrupted,=,True
#,the,next,_writeBlock,call,will,notice,the,.interrupted,flag
def,finished(self,,res):
if,self.debug:
log.msg('finished:,stderr=%r,,rc=%r',%,(self.stderr,,self.rc))
if,self.stderr,is,None:
self.sendStatus({'rc':,self.rc})
else:
self.sendStatus({'stderr':,self.stderr,,'rc':,self.rc})
return,res
registerSlaveCommand("uploadFile",,SlaveFileUploadCommand,,command_version)
class,SlaveDirectoryUploadCommand(Command):
"""
Upload,a,directory,from,slave,to,build,master
Arguments:
-,['workdir']:,,,base,directory,to,use
-,['slavesrc']:,,name,of,the,slave-side,directory,to,read,from
-,['writer']:,,,,RemoteReference,to,a,transfer._DirectoryWriter,object
-,['maxsize']:,,,max,size,(in,bytes),of,file,to,write
-,['blocksize']:,max,size,for,each,data,block
"""
debug,=,True
def,setup(self,,args):
self.workdir,=,args['workdir']
self.dirname,=,args['slavesrc']
self.writer,=,args['writer']
self.remaining,=,args['maxsize']
self.blocksize,=,args['blocksize']
self.stderr,=,None
self.rc,=,0
def,start(self):
if,self.debug:
log.msg('SlaveDirectoryUploadCommand,started')
	#,create,some,lists,with,all,files,and,directories
	foundFiles,=,[]
	foundDirs,=,[]
	self.baseRoot,=,os.path.join(self.builder.basedir,
self.workdir,
	,,,,,os.path.expanduser(self.dirname))
	if,self.debug:
	,,,,log.msg("baseRoot:,%r",%,self.baseRoot)
	for,root,,dirs,,files,in,os.walk(self.baseRoot):
	,,,,tempRoot,=,root
	,,,,relRoot,=,''
	,,,,while,(tempRoot,!=,self.baseRoot):
	,,,,,,,,tempRoot,,tempRelRoot,=,os.path.split(tempRoot)
	,,,,,,,,relRoot,=,os.path.join(tempRelRoot,,relRoot)
	,,,,for,name,in,files:
	,,,,,,,,foundFiles.append(os.path.join(relRoot,,name))
	,,,,for,directory,in,dirs:
	,,,,,,,,foundDirs.append(os.path.join(relRoot,,directory))
	if,self.debug:
	,,,,log.msg("foundDirs:,%s",%,(str(foundDirs)))
	,,,,log.msg("foundFiles:,%s",%,(str(foundFiles)))
	
	#,create,all,directories,on,the,master,,to,catch,also,empty,ones
	for,dirname,in,foundDirs:
	,,,,self.writer.callRemote("createdir",,dirname)
	for,filename,in,foundFiles:
	,,,,self._writeFile(filename)
	return,None
def,_writeFile(self,,filename):
"""Write,a,file,to,the,remote,writer"""
log.msg("_writeFile:,%r",%,(filename))
	self.writer.callRemote('open',,filename)
	data,=,open(os.path.join(self.baseRoot,,filename),,"r").read()
	self.writer.callRemote('write',,data)
	self.writer.callRemote('close')
return,None
def,interrupt(self):
if,self.debug:
log.msg('interrupted')
if,self.interrupted:
return
if,self.stderr,is,None:
self.stderr,=,'Upload,of,%r,interrupted',%,self.path
self.rc,=,1
self.interrupted,=,True
#,the,next,_writeBlock,call,will,notice,the,.interrupted,flag
def,finished(self,,res):
if,self.debug:
log.msg('finished:,stderr=%r,,rc=%r',%,(self.stderr,,self.rc))
if,self.stderr,is,None:
self.sendStatus({'rc':,self.rc})
else:
self.sendStatus({'stderr':,self.stderr,,'rc':,self.rc})
return,res
registerSlaveCommand("uploadDirectory",,SlaveDirectoryUploadCommand,,command_version)
class,SlaveFileDownloadCommand(Command):
"""
Download,a,file,from,master,to,slave
Arguments:
-,['workdir']:,,,base,directory,to,use
-,['slavedest']:,name,of,the,slave-side,file,to,be,created
-,['reader']:,,,,RemoteReference,to,a,transfer._FileReader,object
-,['maxsize']:,,,max,size,(in,bytes),of,file,to,write
-,['blocksize']:,max,size,for,each,data,block
-,['mode']:,,,,,,access,mode,for,the,new,file
"""
debug,=,False
def,setup(self,,args):
self.workdir,=,args['workdir']
self.filename,=,args['slavedest']
self.reader,=,args['reader']
self.bytes_remaining,=,args['maxsize']
self.blocksize,=,args['blocksize']
self.mode,=,args['mode']
self.stderr,=,None
self.rc,=,0
def,start(self):
if,self.debug:
log.msg('SlaveFileDownloadCommand,starting')
#,Open,file
self.path,=,os.path.join(self.builder.basedir,
self.workdir,
os.path.expanduser(self.filename))
dirname,=,os.path.dirname(self.path)
if,not,os.path.exists(dirname):
os.makedirs(dirname)
try:
self.fp,=,open(self.path,,'wb')
if,self.debug:
log.msg('Opened,%r,for,download',%,self.path)
if,self.mode,is,not,None:
#,note:,there,is,a,brief,window,during,which,the,new,file
#,will,have,the,buildslave's,default,(umask),mode,before,we
#,set,the,new,one.,Don't,use,this,mode=,feature,to,keep,files
#,private:,use,the,buildslave's,umask,for,that,instead.,(it
#,is,possible,to,call,os.umask(),before,and,after,the,open()
#,call,,but,cleaning,up,from,exceptions,properly,is,more,of,a
#,nuisance,that,way).
os.chmod(self.path,,self.mode)
except,IOError:
#,TODO:,this,still,needs,cleanup
self.fp,=,None
self.stderr,=,'Cannot,open,file,%r,for,download',%,self.path
self.rc,=,1
if,self.debug:
log.msg('Cannot,open,file,%r,for,download',%,self.path)
d,=,defer.Deferred()
reactor.callLater(0,,self._loop,,d)
def,_close(res):
#,close,the,file,,but,pass,through,any,errors,from,_loop
d1,=,self.reader.callRemote('close')
d1.addErrback(log.err)
d1.addCallback(lambda,ignored:,res)
return,d1
d.addBoth(_close)
d.addBoth(self.finished)
return,d
def,_loop(self,,fire_when_done):
d,=,defer.maybeDeferred(self._readBlock)
def,_done(finished):
if,finished:
fire_when_done.callback(None)
else:
self._loop(fire_when_done)
def,_err(why):
fire_when_done.errback(why)
d.addCallbacks(_done,,_err)
return,None
def,_readBlock(self):
"""Read,a,block,of,data,from,the,remote,reader."""
if,self.interrupted,or,self.fp,is,None:
if,self.debug:
log.msg('SlaveFileDownloadCommand._readBlock():,end')
return,True
length,=,self.blocksize
if,self.bytes_remaining,is,not,None,and,length,>,self.bytes_remaining:
length,=,self.bytes_remaining
if,length,<=,0:
if,self.stderr,is,None:
self.stderr,=,'Maximum,filesize,reached,,truncating,file,%r',\
%,self.path
self.rc,=,1
return,True
else:
d,=,self.reader.callRemote('read',,length)
d.addCallback(self._writeData)
return,d
def,_writeData(self,,data):
if,self.debug:
log.msg('SlaveFileDownloadCommand._readBlock():,readlen=%d',%
len(data))
if,len(data),==,0:
return,True
if,self.bytes_remaining,is,not,None:
self.bytes_remaining,=,self.bytes_remaining,-,len(data)
assert,self.bytes_remaining,>=,0
self.fp.write(data)
return,False
def,interrupt(self):
if,self.debug:
log.msg('interrupted')
if,self.interrupted:
return
if,self.stderr,is,None:
self.stderr,=,'Download,of,%r,interrupted',%,self.path
self.rc,=,1
self.interrupted,=,True
#,now,we,wait,for,the,next,read,request,to,return.,_readBlock,will
#,abandon,the,file,when,it,sees,self.interrupted,set.
def,finished(self,,res):
if,self.fp,is,not,None:
self.fp.close()
if,self.debug:
log.msg('finished:,stderr=%r,,rc=%r',%,(self.stderr,,self.rc))
if,self.stderr,is,None:
self.sendStatus({'rc':,self.rc})
else:
self.sendStatus({'stderr':,self.stderr,,'rc':,self.rc})
return,res
registerSlaveCommand("downloadFile",,SlaveFileDownloadCommand,,command_version)
class,SlaveShellCommand(Command):
"""This,is,a,Command,which,runs,a,shell,command.,The,args,dict,contains
the,following,keys:
-,['command'],(required):,a,shell,command,to,run.,If,this,is,a,string,
it,will,be,run,with,/bin/sh,(['/bin/sh',
'-c',,command]).,If,it,is,a,list
(preferred),,it,will,be,used,directly.
-,['workdir'],(required):,subdirectory,in,which,the,command,will,be
run,,relative,to,the,builder,dir
-,['env']:,a,dict,of,environment,variables,to,augment/replace
os.environ,.,PYTHONPATH,is,treated,specially,,and
should,be,a,list,of,path,components,to,be,prepended,to
any,existing,PYTHONPATH,environment,variable.
-,['initial_stdin']:,a,string,which,will,be,written,to,the,command's
stdin,as,soon,as,it,starts
-,['keep_stdin_open']:,unless,True,,the,command's,stdin,will,be
closed,as,soon,as,initial_stdin,has,been
written.,Set,this,to,True,if,you,plan,to,write
to,stdin,after,the,command,has,been,started.
-,['want_stdout']:,0,if,stdout,should,be,thrown,away
-,['want_stderr']:,0,if,stderr,should,be,thrown,away
-,['usePTY']:,True,or,False,if,the,command,should,use,a,PTY,(defaults,to
configuration,of,the,slave)
-,['not_really']:,1,to,skip,execution,and,return,rc=0
-,['timeout']:,seconds,of,silence,to,tolerate,before,killing,command
-,['logfiles']:,dict,mapping,LogFile,name,to,the,workdir-relative
filename,of,a,local,log,file.,This,local,file,will,be
watched,just,like,'tail,-f',,and,all,changes,will,be
written,to,'log',status,updates.
ShellCommand,creates,the,following,status,messages:
-,{'stdout':,data},:,when,stdout,data,is,available
-,{'stderr':,data},:,when,stderr,data,is,available
-,{'header':,data},:,when,headers,(command,start/stop),are,available
-,{'log':,(logfile_name,,data)},:,when,log,files,have,new,contents
-,{'rc':,rc},:,when,the,process,has,terminated
"""
def,start(self):
args,=,self.args
#,args['workdir'],is,relative,to,Builder,directory,,and,is,required.
assert,args['workdir'],is,not,None
workdir,=,os.path.join(self.builder.basedir,,args['workdir'])
c,=,ShellCommand(self.builder,,args['command'],
workdir,,environ=args.get('env'),
timeout=args.get('timeout',,None),
sendStdout=args.get('want_stdout',,True),
sendStderr=args.get('want_stderr',,True),
sendRC=True,
initialStdin=args.get('initial_stdin'),
keepStdinOpen=args.get('keep_stdin_open'),
logfiles=args.get('logfiles',,{}),
usePTY=args.get('usePTY',,"slave-config"),
)
self.command,=,c
d,=,self.command.start()
return,d
def,interrupt(self):
self.interrupted,=,True
self.command.kill("command,interrupted")
def,writeStdin(self,,data):
self.command.writeStdin(data)
def,closeStdin(self):
self.command.closeStdin()
registerSlaveCommand("shell",,SlaveShellCommand,,command_version)
class,DummyCommand(Command):
"""
I,am,a,dummy,no-op,command,that,by,default,takes,5,seconds,to,complete.
See,L{buildbot.steps.dummy.RemoteDummy}
"""
def,start(self):
self.d,=,defer.Deferred()
log.msg(",,starting,dummy,command,[%s]",%,self.stepId)
self.timer,=,reactor.callLater(1,,self.doStatus)
return,self.d
def,interrupt(self):
if,self.interrupted:
return
self.timer.cancel()
self.timer,=,None
self.interrupted,=,True
self.finished()
def,doStatus(self):
log.msg(",,sending,intermediate,status")
self.sendStatus({'stdout':,'data'})
timeout,=,self.args.get('timeout',,5),+,1
self.timer,=,reactor.callLater(timeout,-,1,,self.finished)
def,finished(self):
log.msg(",,dummy,command,finished,[%s]",%,self.stepId)
if,self.interrupted:
self.sendStatus({'rc':,1})
else:
self.sendStatus({'rc':,0})
self.d.callback(0)
registerSlaveCommand("dummy",,DummyCommand,,command_version)
#,this,maps,handle,names,to,a,callable.,When,the,WaitCommand,starts,,this
#,callable,is,invoked,with,no,arguments.,It,should,return,a,Deferred.,When
#,that,Deferred,fires,,our,WaitCommand,will,finish.
waitCommandRegistry,=,{}
class,WaitCommand(Command):
"""
I,am,a,dummy,command,used,by,the,buildbot,unit,test,suite.,I,want,for,the
unit,test,to,tell,us,to,finish.,See,L{buildbot.steps.dummy.Wait}
"""
def,start(self):
self.d,=,defer.Deferred()
log.msg(",,starting,wait,command,[%s]",%,self.stepId)
handle,=,self.args['handle']
cb,=,waitCommandRegistry[handle]
del,waitCommandRegistry[handle]
def,_called():
log.msg(",wait-%s,starting",%,(handle,))
d,=,cb()
def,_done(res):
log.msg(",wait-%s,finishing:,%s",%,(handle,,res))
return,res
d.addBoth(_done)
d.addCallbacks(self.finished,,self.failed)
reactor.callLater(0,,_called)
return,self.d
def,interrupt(self):
log.msg(",,wait,command,interrupted")
if,self.interrupted:
return
self.interrupted,=,True
self.finished("interrupted")
def,finished(self,,res):
log.msg(",,wait,command,finished,[%s]",%,self.stepId)
if,self.interrupted:
self.sendStatus({'rc':,2})
else:
self.sendStatus({'rc':,0})
self.d.callback(0)
def,failed(self,,why):
log.msg(",,wait,command,failed,[%s]",%,self.stepId)
self.sendStatus({'rc':,1})
self.d.callback(0)
registerSlaveCommand("dummy.wait",,WaitCommand,,command_version)
class,SourceBase(Command):
"""Abstract,base,class,for,Version,Control,System,operations,(checkout
and,update).,This,class,extracts,the,following,arguments,from,the
dictionary,received,from,the,master:
-,['workdir']:,,(required),the,subdirectory,where,the,buildable,sources
should,be,placed
-,['mode']:,,,,,one,of,update/copy/clobber/export,,defaults,to,'update'
-,['revision']:,If,not,None,,this,is,an,int,or,string,which,indicates
which,sources,(along,a,time-like,axis),should,be,used.
It,is,the,thing,you,provide,as,the,CVS,-r,or,-D
argument.
-,['patch']:,,,,If,not,None,,this,is,a,tuple,of,(striplevel,,patch)
which,contains,a,patch,that,should,be,applied,after,the
checkout,has,occurred.,Once,applied,,the,tree,is,no
longer,eligible,for,use,with,mode='update',,and,it,only
makes,sense,to,use,this,in,conjunction,with,a
['revision'],argument.,striplevel,is,an,int,,and,patch
is,a,string,in,standard,unified,diff,format.,The,patch
will,be,applied,with,'patch,-p%d,<PATCH',,with
STRIPLEVEL,substituted,as,%d.,The,command,will,fail,if
the,patch,process,fails,(rejected,hunks).
-,['timeout']:,,seconds,of,silence,tolerated,before,we,kill,off,the
command
-,['retry']:,,,,If,not,None,,this,is,a,tuple,of,(delay,,repeats)
which,means,that,any,failed,VC,updates,should,be
reattempted,,up,to,REPEATS,times,,after,a,delay,of
DELAY,seconds.,This,is,intended,to,deal,with,slaves
that,experience,transient,network,failures.
"""
sourcedata,=,""
def,setup(self,,args):
#,if,we,need,to,parse,the,output,,use,this,environment.,Otherwise
#,command,output,will,be,in,whatever,the,buildslave's,native,language
#,has,been,set,to.
self.env,=,os.environ.copy()
self.env['LC_MESSAGES'],=,"C"
self.workdir,=,args['workdir']
self.mode,=,args.get('mode',,"update")
self.revision,=,args.get('revision')
self.patch,=,args.get('patch')
self.timeout,=,args.get('timeout',,120)
self.retry,=,args.get('retry')
#,VC-specific,subclasses,should,override,this,to,extract,more,args.
#,Make,sure,to,upcall!
def,start(self):
self.sendStatus({'header':,"starting,",+,self.header,+,"\n"})
self.command,=,None
#,self.srcdir,is,where,the,VC,system,should,put,the,sources
if,self.mode,==,"copy":
self.srcdir,=,"source",#,hardwired,directory,name,,sorry
else:
self.srcdir,=,self.workdir
self.sourcedatafile,=,os.path.join(self.builder.basedir,
self.srcdir,
".buildbot-sourcedata")
d,=,defer.succeed(None)
self.maybeClobber(d)
if,not,(self.sourcedirIsUpdateable(),and,self.sourcedataMatches()):
#,the,directory,cannot,be,updated,,so,we,have,to,clobber,it.
#,Perhaps,the,master,just,changed,modes,from,'export',to
#,'update'.
d.addCallback(self.doClobber,,self.srcdir)
d.addCallback(self.doVC)
if,self.mode,==,"copy":
d.addCallback(self.doCopy)
if,self.patch:
d.addCallback(self.doPatch)
d.addCallbacks(self._sendRC,,self._checkAbandoned)
return,d
def,maybeClobber(self,,d):
#,do,we,need,to,clobber,anything?
if,self.mode,in,("copy",,"clobber",,"export"):
d.addCallback(self.doClobber,,self.workdir)
def,interrupt(self):
self.interrupted,=,True
if,self.command:
self.command.kill("command,interrupted")
def,doVC(self,,res):
if,self.interrupted:
raise,AbandonChain(1)
if,self.sourcedirIsUpdateable(),and,self.sourcedataMatches():
d,=,self.doVCUpdate()
d.addCallback(self.maybeDoVCFallback)
else:
d,=,self.doVCFull()
d.addBoth(self.maybeDoVCRetry)
d.addCallback(self._abandonOnFailure)
d.addCallback(self._handleGotRevision)
d.addCallback(self.writeSourcedata)
return,d
def,sourcedataMatches(self):
try:
olddata,=,open(self.sourcedatafile,,"r").read()
if,olddata,!=,self.sourcedata:
return,False
except,IOError:
return,False
return,True
def,_handleGotRevision(self,,res):
d,=,defer.maybeDeferred(self.parseGotRevision)
d.addCallback(lambda,got_revision:
self.sendStatus({'got_revision':,got_revision}))
return,d
def,parseGotRevision(self):
"""Override,this,in,a,subclass.,It,should,return,a,string,that
represents,which,revision,was,actually,checked,out,,or,a,Deferred
that,will,fire,with,such,a,string.,If,,in,a,future,build,,you,were,to
pass,this,'got_revision',string,in,as,the,'revision',component,of,a
SourceStamp,,you,should,wind,up,with,the,same,source,code,as,this
checkout,just,obtained.
It,is,probably,most,useful,to,scan,self.command.stdout,for,a,string
of,some,sort.,Be,sure,to,set,keepStdout=True,on,the,VC,command,that
you,run,,so,that,you'll,have,something,available,to,look,at.
If,this,information,is,unavailable,,just,return,None."""
return,None
def,writeSourcedata(self,,res):
open(self.sourcedatafile,,"w").write(self.sourcedata)
return,res
def,sourcedirIsUpdateable(self):
raise,NotImplementedError("this,must,be,implemented,in,a,subclass")
def,doVCUpdate(self):
raise,NotImplementedError("this,must,be,implemented,in,a,subclass")
def,doVCFull(self):
raise,NotImplementedError("this,must,be,implemented,in,a,subclass")
def,maybeDoVCFallback(self,,rc):
if,type(rc),is,int,and,rc,==,0:
return,rc
if,self.interrupted:
raise,AbandonChain(1)
msg,=,"update,failed,,clobbering,and,trying,again"
self.sendStatus({'header':,msg,+,"\n"})
log.msg(msg)
d,=,self.doClobber(None,,self.srcdir)
d.addCallback(self.doVCFallback2)
return,d
def,doVCFallback2(self,,res):
msg,=,"now,retrying,VC,operation"
self.sendStatus({'header':,msg,+,"\n"})
log.msg(msg)
d,=,self.doVCFull()
d.addBoth(self.maybeDoVCRetry)
d.addCallback(self._abandonOnFailure)
return,d
def,maybeDoVCRetry(self,,res):
"""We,get,here,somewhere,after,a,VC,chain,has,finished.,res,could
be::
-,0:,the,operation,was,successful
-,nonzero:,the,operation,failed.,retry,if,possible
-,AbandonChain:,the,operation,failed,,someone,else,noticed.,retry.
-,Failure:,some,other,exception,,re-raise
"""
if,isinstance(res,,failure.Failure):
if,self.interrupted:
return,res,#,don't,re-try,interrupted,builds
res.trap(AbandonChain)
else:
if,type(res),is,int,and,res,==,0:
return,res
if,self.interrupted:
raise,AbandonChain(1)
#,if,we,get,here,,we,should,retry,,if,possible
if,self.retry:
delay,,repeats,=,self.retry
if,repeats,>=,0:
self.retry,=,(delay,,repeats-1)
msg,=,("update,failed,,trying,%d,more,times,after,%d,seconds"
%,(repeats,,delay))
self.sendStatus({'header':,msg,+,"\n"})
log.msg(msg)
d,=,defer.Deferred()
self.maybeClobber(d)
d.addCallback(lambda,res:,self.doVCFull())
d.addBoth(self.maybeDoVCRetry)
reactor.callLater(delay,,d.callback,,None)
return,d
return,res
def,doClobber(self,,dummy,,dirname):
#,TODO:,remove,the,old,tree,in,the,background
##,,,,,,,,,workdir,=,os.path.join(self.builder.basedir,,self.workdir)
##,,,,,,,,,deaddir,=,self.workdir,+,".deleting"
##,,,,,,,,,if,os.path.isdir(workdir):
##,,,,,,,,,,,,,try:
##,,,,,,,,,,,,,,,,,os.rename(workdir,,deaddir)
##,,,,,,,,,,,,,,,,,#,might,fail,if,deaddir,already,exists:,previous,deletion
##,,,,,,,,,,,,,,,,,#,hasn't,finished,yet
##,,,,,,,,,,,,,,,,,#,start,the,deletion,in,the,background
##,,,,,,,,,,,,,,,,,#,TODO:,there,was,a,solaris/NetApp/NFS,problem,where,a
##,,,,,,,,,,,,,,,,,#,process,that,was,still,running,out,of,the,directory,we're
##,,,,,,,,,,,,,,,,,#,trying,to,delete,could,prevent,the,rm-rf,from,working.,I
##,,,,,,,,,,,,,,,,,#,think,it,stalled,the,rm,,but,maybe,it,just,died,with
##,,,,,,,,,,,,,,,,,#,permission,issues.,Try,to,detect,this.
##,,,,,,,,,,,,,,,,,os.commands("rm,-rf,%s,&",%,deaddir)
##,,,,,,,,,,,,,except:
##,,,,,,,,,,,,,,,,,#,fall,back,to,sequential,delete-then-checkout
##,,,,,,,,,,,,,,,,,pass
d,=,os.path.join(self.builder.basedir,,dirname)
if,runtime.platformType,!=,"posix":
#,if,we're,running,on,w32,,use,rmtree,instead.,It,will,block,
#,but,hopefully,it,won't,take,too,long.
rmdirRecursive(d)
return,defer.succeed(0)
command,=,["rm",,"-rf",,d]
c,=,ShellCommand(self.builder,,command,,self.builder.basedir,
sendRC=0,,timeout=self.timeout,,usePTY=False)
self.command,=,c
#,sendRC=0,means,the,rm,command,will,send,stdout/stderr,to,the
#,master,,but,not,the,rc=0,when,it,finishes.,That,job,is,left,to
#,_sendRC
d,=,c.start()
d.addCallback(self._abandonOnFailure)
return,d
def,doCopy(self,,res):
#,now,copy,tree,to,workdir
fromdir,=,os.path.join(self.builder.basedir,,self.srcdir)
todir,=,os.path.join(self.builder.basedir,,self.workdir)
if,runtime.platformType,!=,"posix":
self.sendStatus({'header':,"Since,we're,on,a,non-POSIX,platform,,"
"we're,not,going,to,try,to,execute,cp,in,a,subprocess,,but,instead,"
"use,shutil.copytree(),,which,will,block,until,it,is,complete.,,"
"fromdir:,%s,,todir:,%s\n",%,(fromdir,,todir)})
shutil.copytree(fromdir,,todir)
return,defer.succeed(0)
if,not,os.path.exists(os.path.dirname(todir)):
os.makedirs(os.path.dirname(todir))
if,os.path.exists(todir):
#,I,don't,think,this,happens,,but,just,in,case..
log.msg("cp,target,'%s',already,exists,--,cp,will,not,do,what,you,think!",%,todir)
command,=,['cp',,'-R',,'-P',,'-p',,fromdir,,todir]
c,=,ShellCommand(self.builder,,command,,self.builder.basedir,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
d,=,c.start()
d.addCallback(self._abandonOnFailure)
return,d
def,doPatch(self,,res):
patchlevel,,diff,=,self.patch
command,=,[getCommand("patch"),,'-p%d',%,patchlevel]
dir,=,os.path.join(self.builder.basedir,,self.workdir)
#,mark,the,directory,so,we,don't,try,to,update,it,later
open(os.path.join(dir,,".buildbot-patched"),,"w").write("patched\n")
#,now,apply,the,patch
c,=,ShellCommand(self.builder,,command,,dir,
sendRC=False,,timeout=self.timeout,
initialStdin=diff,,usePTY=False)
self.command,=,c
d,=,c.start()
d.addCallback(self._abandonOnFailure)
return,d
class,CVS(SourceBase):
"""CVS-specific,VC,operation.,In,addition,to,the,arguments,handled,by
SourceBase,,this,command,reads,the,following,keys:
['cvsroot'],(required):,the,CVSROOT,repository,string
['cvsmodule'],(required):,the,module,to,be,retrieved
['branch']:,a,'-r',tag,or,branch,name,to,use,for,the,checkout/update
['login']:,a,string,for,use,as,a,password,to,'cvs,login'
['global_options']:,a,list,of,strings,to,use,before,the,CVS,verb
"""
header,=,"cvs,operation"
def,setup(self,,args):
SourceBase.setup(self,,args)
self.vcexe,=,getCommand("cvs")
self.cvsroot,=,args['cvsroot']
self.cvsmodule,=,args['cvsmodule']
self.global_options,=,args.get('global_options',,[])
self.branch,=,args.get('branch')
self.login,=,args.get('login')
self.sourcedata,=,"%s\n%s\n%s\n",%,(self.cvsroot,,self.cvsmodule,
self.branch)
def,sourcedirIsUpdateable(self):
if,os.path.exists(os.path.join(self.builder.basedir,
self.srcdir,,".buildbot-patched")):
return,False
return,os.path.isdir(os.path.join(self.builder.basedir,
self.srcdir,,"CVS"))
def,start(self):
if,self.login,is,not,None:
#,need,to,do,a,'cvs,login',command,first
d,=,self.builder.basedir
command,=,([self.vcexe,,'-d',,self.cvsroot],+,self.global_options
+,['login'])
c,=,ShellCommand(self.builder,,command,,d,
sendRC=False,,timeout=self.timeout,
initialStdin=self.login+"\n",,usePTY=False)
self.command,=,c
d,=,c.start()
d.addCallback(self._abandonOnFailure)
d.addCallback(self._didLogin)
return,d
else:
return,self._didLogin(None)
def,_didLogin(self,,res):
#,now,we,really,start
return,SourceBase.start(self)
def,doVCUpdate(self):
d,=,os.path.join(self.builder.basedir,,self.srcdir)
command,=,[self.vcexe,,'-z3'],+,self.global_options,+,['update',,'-dP']
if,self.branch:
command,+=,['-r',,self.branch]
if,self.revision:
command,+=,['-D',,self.revision]
c,=,ShellCommand(self.builder,,command,,d,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
return,c.start()
def,doVCFull(self):
d,=,self.builder.basedir
if,self.mode,==,"export":
verb,=,"export"
else:
verb,=,"checkout"
command,=,([self.vcexe,,'-d',,self.cvsroot,,'-z3'],+
self.global_options,+
[verb,,'-d',,self.srcdir])
if,self.branch:
command,+=,['-r',,self.branch]
if,self.revision:
command,+=,['-D',,self.revision]
command,+=,[self.cvsmodule]
c,=,ShellCommand(self.builder,,command,,d,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
return,c.start()
def,parseGotRevision(self):
#,CVS,does,not,have,any,kind,of,revision,stamp,to,speak,of.,We,return
#,the,current,timestamp,as,a,best-effort,guess,,but,this,depends,upon
#,the,local,system,having,a,clock,that,is
#,reasonably-well-synchronized,with,the,repository.
return,time.strftime("%Y-%m-%d,%H:%M:%S,+0000",,time.gmtime())
registerSlaveCommand("cvs",,CVS,,command_version)
class,SVN(SourceBase):
"""Subversion-specific,VC,operation.,In,addition,to,the,arguments
handled,by,SourceBase,,this,command,reads,the,following,keys:
['svnurl'],(required):,the,SVN,repository,string
['username'],,,,Username,passed,to,the,svn,command
['password'],,,,Password,passed,to,the,svn,command
"""
header,=,"svn,operation"
def,setup(self,,args):
SourceBase.setup(self,,args)
self.vcexe,=,getCommand("svn")
self.svnurl,=,args['svnurl']
self.sourcedata,=,"%s\n",%,self.svnurl
self.extra_args,=,[]
if,args.has_key('username'):
self.extra_args.extend(["--username",,args['username']])
if,args.has_key('password'):
self.extra_args.extend(["--password",,Obfuscated(args['password'],,"XXXX")])
def,sourcedirIsUpdateable(self):
if,os.path.exists(os.path.join(self.builder.basedir,
self.srcdir,,".buildbot-patched")):
return,False
return,os.path.isdir(os.path.join(self.builder.basedir,
self.srcdir,,".svn"))
def,doVCUpdate(self):
revision,=,self.args['revision'],or,'HEAD'
#,update:,possible,for,mode,in,('copy',,'update')
d,=,os.path.join(self.builder.basedir,,self.srcdir)
command,=,[self.vcexe,,'update'],+,\
self.extra_args,+,\
['--revision',,str(revision),
'--non-interactive',,'--no-auth-cache']
c,=,ShellCommand(self.builder,,command,,d,
sendRC=False,,timeout=self.timeout,
keepStdout=True,,usePTY=False)
self.command,=,c
return,c.start()
def,doVCFull(self):
revision,=,self.args['revision'],or,'HEAD'
d,=,self.builder.basedir
if,self.mode,==,"export":
command,=,[self.vcexe,,'export'],+,\
self.extra_args,+,\
['--revision',,str(revision),
'--non-interactive',,'--no-auth-cache',
self.svnurl,,self.srcdir]
else:
#,mode=='clobber',,or,copy/update,on,a,broken,workspace
command,=,[self.vcexe,,'checkout'],+,\
self.extra_args,+,\
['--revision',,str(revision),
'--non-interactive',,'--no-auth-cache',
self.svnurl,,self.srcdir]
c,=,ShellCommand(self.builder,,command,,d,
sendRC=False,,timeout=self.timeout,
keepStdout=True,,usePTY=False)
self.command,=,c
return,c.start()
def,getSvnVersionCommand(self):
"""
Get,the,(shell),command,used,to,determine,SVN,revision,number
of,checked-out,code
return:,list,of,strings,,passable,as,the,command,argument,to,ShellCommand
"""
#,svn,checkout,operations,finish,with,'Checked,out,revision,16657.'
#,svn,update,operations,finish,the,line,'At,revision,16654.'
#,But,we,don't,use,those.,Instead,,run,'svnversion'.
svnversion_command,=,getCommand("svnversion")
#,older,versions,of,'svnversion',(1.1.4),require,the,WC_PATH
#,argument,,newer,ones,(1.3.1),do,not.
return,[svnversion_command,,"."]
def,parseGotRevision(self):
c,=,ShellCommand(self.builder,
self.getSvnVersionCommand(),
os.path.join(self.builder.basedir,,self.srcdir),
environ=self.env,
sendStdout=False,,sendStderr=False,,sendRC=False,
keepStdout=True,,usePTY=False)
d,=,c.start()
def,_parse(res):
r_raw,=,c.stdout.strip()
#,Extract,revision,from,the,version,"number",string
r,=,r_raw.rstrip('MS')
r,=,r.split(':')[-1]
got_version,=,None
try:
got_version,=,int(r)
except,ValueError:
msg,=("SVN.parseGotRevision,unable,to,parse,output,"
"of,svnversion:,'%s'",%,r_raw)
log.msg(msg)
self.sendStatus({'header':,msg,+,"\n"})
return,got_version
d.addCallback(_parse)
return,d
registerSlaveCommand("svn",,SVN,,command_version)
class,Darcs(SourceBase):
"""Darcs-specific,VC,operation.,In,addition,to,the,arguments
handled,by,SourceBase,,this,command,reads,the,following,keys:
['repourl'],(required):,the,Darcs,repository,string
"""
header,=,"darcs,operation"
def,setup(self,,args):
SourceBase.setup(self,,args)
self.vcexe,=,getCommand("darcs")
self.repourl,=,args['repourl']
self.sourcedata,=,"%s\n",%,self.repourl
self.revision,=,self.args.get('revision')
def,sourcedirIsUpdateable(self):
if,os.path.exists(os.path.join(self.builder.basedir,
self.srcdir,,".buildbot-patched")):
return,False
if,self.revision:
#,checking,out,a,specific,revision,requires,a,full,'darcs,get'
return,False
return,os.path.isdir(os.path.join(self.builder.basedir,
self.srcdir,,"_darcs"))
def,doVCUpdate(self):
assert,not,self.revision
#,update:,possible,for,mode,in,('copy',,'update')
d,=,os.path.join(self.builder.basedir,,self.srcdir)
command,=,[self.vcexe,,'pull',,'--all',,'--verbose']
c,=,ShellCommand(self.builder,,command,,d,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
return,c.start()
def,doVCFull(self):
#,checkout,or,export
d,=,self.builder.basedir
command,=,[self.vcexe,,'get',,'--verbose',,'--partial',
'--repo-name',,self.srcdir]
if,self.revision:
#,write,the,context,to,a,file
n,=,os.path.join(self.builder.basedir,,".darcs-context")
f,=,open(n,,"wb")
f.write(self.revision)
f.close()
#,tell,Darcs,to,use,that,context
command.append('--context')
command.append(n)
command.append(self.repourl)
c,=,ShellCommand(self.builder,,command,,d,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
d,=,c.start()
if,self.revision:
d.addCallback(self.removeContextFile,,n)
return,d
def,removeContextFile(self,,res,,n):
os.unlink(n)
return,res
def,parseGotRevision(self):
#,we,use,'darcs,context',to,find,out,what,we,wound,up,with
command,=,[self.vcexe,,"changes",,"--context"]
c,=,ShellCommand(self.builder,,command,
os.path.join(self.builder.basedir,,self.srcdir),
environ=self.env,
sendStdout=False,,sendStderr=False,,sendRC=False,
keepStdout=True,,usePTY=False)
d,=,c.start()
d.addCallback(lambda,res:,c.stdout)
return,d
registerSlaveCommand("darcs",,Darcs,,command_version)
class,Monotone(SourceBase):
"""Monotone-specific,VC,operation.,,In,addition,to,the,arguments,handled
by,SourceBase,,this,command,reads,the,following,keys:
['server_addr'],(required):,the,address,of,the,server,to,pull,from
['branch'],(required):,the,branch,the,revision,is,on
['db_path'],(required):,the,local,database,path,to,use
['revision'],(required):,the,revision,to,check,out
['monotone']:,(required):,path,to,monotone,executable
"""
header,=,"monotone,operation"
def,setup(self,,args):
SourceBase.setup(self,,args)
self.server_addr,=,args["server_addr"]
self.branch,=,args["branch"]
self.db_path,=,args["db_path"]
self.revision,=,args["revision"]
self.monotone,=,args["monotone"]
self._made_fulls,=,False
self._pull_timeout,=,args["timeout"]
def,_makefulls(self):
if,not,self._made_fulls:
basedir,=,self.builder.basedir
self.full_db_path,=,os.path.join(basedir,,self.db_path)
self.full_srcdir,=,os.path.join(basedir,,self.srcdir)
self._made_fulls,=,True
def,sourcedirIsUpdateable(self):
self._makefulls()
if,os.path.exists(os.path.join(self.full_srcdir,
".buildbot_patched")):
return,False
return,(os.path.isfile(self.full_db_path)
and,os.path.isdir(os.path.join(self.full_srcdir,,"MT")))
def,doVCUpdate(self):
return,self._withFreshDb(self._doUpdate)
def,_doUpdate(self):
#,update:,possible,for,mode,in,('copy',,'update')
command,=,[self.monotone,,"update",
"-r",,self.revision,
"-b",,self.branch]
c,=,ShellCommand(self.builder,,command,,self.full_srcdir,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
return,c.start()
def,doVCFull(self):
return,self._withFreshDb(self._doFull)
def,_doFull(self):
command,=,[self.monotone,,"--db=",+,self.full_db_path,
"checkout",
"-r",,self.revision,
"-b",,self.branch,
self.full_srcdir]
c,=,ShellCommand(self.builder,,command,,self.builder.basedir,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
return,c.start()
def,_withFreshDb(self,,callback):
self._makefulls()
#,first,ensure,the,db,exists,and,is,usable
if,os.path.isfile(self.full_db_path):
#,already,exists,,so,run,'db,migrate',in,case,monotone,has,been
#,upgraded,under,us
command,=,[self.monotone,,"db",,"migrate",
"--db=",+,self.full_db_path]
else:
#,We'll,be,doing,an,initial,pull,,so,up,the,timeout,to,3,hours,to
#,make,sure,it,will,have,time,to,complete.
self._pull_timeout,=,max(self._pull_timeout,,3,*,60,*,60)
self.sendStatus({"header":,"creating,database,%s\n"
%,(self.full_db_path,)})
command,=,[self.monotone,,"db",,"init",
"--db=",+,self.full_db_path]
c,=,ShellCommand(self.builder,,command,,self.builder.basedir,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
d,=,c.start()
d.addCallback(self._abandonOnFailure)
d.addCallback(self._didDbInit)
d.addCallback(self._didPull,,callback)
return,d
def,_didDbInit(self,,res):
command,=,[self.monotone,,"--db=",+,self.full_db_path,
"pull",,"--ticker=dot",,self.server_addr,,self.branch]
c,=,ShellCommand(self.builder,,command,,self.builder.basedir,
sendRC=False,,timeout=self._pull_timeout,,usePTY=False)
self.sendStatus({"header":,"pulling,%s,from,%s\n"
%,(self.branch,,self.server_addr)})
self.command,=,c
return,c.start()
def,_didPull(self,,res,,callback):
return,callback()
registerSlaveCommand("monotone",,Monotone,,command_version)
class,Git(SourceBase):
"""Git,specific,VC,operation.,In,addition,to,the,arguments
handled,by,SourceBase,,this,command,reads,the,following,keys:
['repourl'],(required):,the,upstream,GIT,repository,string
['branch'],(optional):,which,version,(i.e.,branch,or,tag),to
retrieve.,Default:,"master".
"""
header,=,"git,operation"
def,setup(self,,args):
SourceBase.setup(self,,args)
self.repourl,=,args['repourl']
self.branch,=,args.get('branch')
if,not,self.branch:
self.branch,=,"master"
self.sourcedata,=,"%s,%s\n",%,(self.repourl,,self.branch)
def,_fullSrcdir(self):
return,os.path.join(self.builder.basedir,,self.srcdir)
def,_commitSpec(self):
if,self.revision:
return,self.revision
return,self.branch
def,sourcedirIsUpdateable(self):
if,os.path.exists(os.path.join(self._fullSrcdir(),
".buildbot-patched")):
return,False
return,os.path.isdir(os.path.join(self._fullSrcdir(),,".git"))
def,readSourcedata(self):
return,open(self.sourcedatafile,,"r").read()
#,If,the,repourl,matches,the,sourcedata,file,,then
#,we,can,say,that,the,sourcedata,matches.,,We,can
#,ignore,branch,changes,,since,Git,can,work,with
#,many,branches,fetched,,and,we,deal,with,it,properly
#,in,doVCUpdate.
def,sourcedataMatches(self):
try:
olddata,=,self.readSourcedata()
if,not,olddata.startswith(self.repourl+','):
return,False
except,IOError:
return,False
return,True
def,_didFetch(self,,res):
if,self.revision:
head,=,self.revision
else:
head,=,'FETCH_HEAD'
command,=,['git',,'reset',,'--hard',,head]
c,=,ShellCommand(self.builder,,command,,self._fullSrcdir(),
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
return,c.start()
#,Update,first,runs,"git,clean",,removing,local,changes,
#,if,the,branch,to,be,checked,out,has,changed.,,This,,combined
#,with,the,later,"git,reset",equates,clobbering,the,repo,
#,but,it's,much,more,efficient.
def,doVCUpdate(self):
try:
#,Check,to,see,if,our,branch,has,changed
diffbranch,=,self.sourcedata,!=,self.readSourcedata()
except,IOError:
diffbranch,=,False
if,diffbranch:
command,=,['git',,'clean',,'-f',,'-d']
c,=,ShellCommand(self.builder,,command,,self._fullSrcdir(),
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
d,=,c.start()
d.addCallback(self._abandonOnFailure)
d.addCallback(self._didClean)
return,d
return,self._didClean(None)
def,_didClean(self,,dummy):
command,=,['git',,'fetch',,'-t',,self.repourl,,self.branch]
self.sendStatus({"header":,"fetching,branch,%s,from,%s\n"
%,(self.branch,,self.repourl)})
c,=,ShellCommand(self.builder,,command,,self._fullSrcdir(),
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
d,=,c.start()
d.addCallback(self._abandonOnFailure)
d.addCallback(self._didFetch)
return,d
def,_didInit(self,,res):
return,self.doVCUpdate()
def,doVCFull(self):
os.mkdir(self._fullSrcdir())
c,=,ShellCommand(self.builder,,['git',,'init'],,self._fullSrcdir(),
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
d,=,c.start()
d.addCallback(self._abandonOnFailure)
d.addCallback(self._didInit)
return,d
def,parseGotRevision(self):
command,=,['git',,'rev-parse',,'HEAD']
c,=,ShellCommand(self.builder,,command,,self._fullSrcdir(),
sendRC=False,,keepStdout=True,,usePTY=False)
d,=,c.start()
def,_parse(res):
hash,=,c.stdout.strip()
if,len(hash),!=,40:
return,None
return,hash
d.addCallback(_parse)
return,d
registerSlaveCommand("git",,Git,,command_version)
class,Arch(SourceBase):
"""Arch-specific,(tla-specific),VC,operation.,In,addition,to,the
arguments,handled,by,SourceBase,,this,command,reads,the,following,keys:
['url'],(required):,the,repository,string
['version'],(required):,which,version,(i.e.,branch),to,retrieve
['revision'],(optional):,the,'patch-NN',argument,to,check,out
['archive']:,the,archive,name,to,use.,If,None,,use,the,archive's,default
['build-config']:,if,present,,give,to,'tla,build-config',after,checkout
"""
header,=,"arch,operation"
buildconfig,=,None
def,setup(self,,args):
SourceBase.setup(self,,args)
self.vcexe,=,getCommand("tla")
self.archive,=,args.get('archive')
self.url,=,args['url']
self.version,=,args['version']
self.revision,=,args.get('revision')
self.buildconfig,=,args.get('build-config')
self.sourcedata,=,"%s\n%s\n%s\n",%,(self.url,,self.version,
self.buildconfig)
def,sourcedirIsUpdateable(self):
if,self.revision:
#,Arch,cannot,roll,a,directory,backwards,,so,if,they,ask,for,a
#,specific,revision,,clobber,the,directory.,Technically,this
#,could,be,limited,to,the,cases,where,the,requested,revision,is
#,later,than,our,current,one,,but,it's,too,hard,to,extract,the
#,current,revision,from,the,tree.
return,False
if,os.path.exists(os.path.join(self.builder.basedir,
self.srcdir,,".buildbot-patched")):
return,False
return,os.path.isdir(os.path.join(self.builder.basedir,
self.srcdir,,"{arch}"))
def,doVCUpdate(self):
#,update:,possible,for,mode,in,('copy',,'update')
d,=,os.path.join(self.builder.basedir,,self.srcdir)
command,=,[self.vcexe,,'replay']
if,self.revision:
command.append(self.revision)
c,=,ShellCommand(self.builder,,command,,d,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
return,c.start()
def,doVCFull(self):
#,to,do,a,checkout,,we,must,first,"register",the,archive,by,giving
#,the,URL,to,tla,,which,will,go,to,the,repository,at,that,URL,and
#,figure,out,the,archive,name.,tla,will,tell,you,the,archive,name
#,when,it,is,done,,and,all,further,actions,must,refer,to,this,name.
command,=,[self.vcexe,,'register-archive',,'--force',,self.url]
c,=,ShellCommand(self.builder,,command,,self.builder.basedir,
sendRC=False,,keepStdout=True,
timeout=self.timeout,,usePTY=False)
self.command,=,c
d,=,c.start()
d.addCallback(self._abandonOnFailure)
d.addCallback(self._didRegister,,c)
return,d
def,_didRegister(self,,res,,c):
#,find,out,what,tla,thinks,the,archive,name,is.,If,the,user,told,us
#,to,use,something,specific,,make,sure,it,matches.
r,=,re.search(r'Registering,archive:,(\S+)\s*$',,c.stdout)
if,r:
msg,=,"tla,reports,archive,name,is,'%s'",%,r.group(1)
log.msg(msg)
self.builder.sendUpdate({'header':,msg+"\n"})
if,self.archive,and,r.group(1),!=,self.archive:
msg,=,(",mismatch,,we,wanted,an,archive,named,'%s'"
%,self.archive)
log.msg(msg)
self.builder.sendUpdate({'header':,msg+"\n"})
raise,AbandonChain(-1)
self.archive,=,r.group(1)
assert,self.archive,,"need,archive,name,to,continue"
return,self._doGet()
def,_doGet(self):
ver,=,self.version
if,self.revision:
ver,+=,"--%s",%,self.revision
command,=,[self.vcexe,,'get',,'--archive',,self.archive,
'--no-pristine',
ver,,self.srcdir]
c,=,ShellCommand(self.builder,,command,,self.builder.basedir,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
d,=,c.start()
d.addCallback(self._abandonOnFailure)
if,self.buildconfig:
d.addCallback(self._didGet)
return,d
def,_didGet(self,,res):
d,=,os.path.join(self.builder.basedir,,self.srcdir)
command,=,[self.vcexe,,'build-config',,self.buildconfig]
c,=,ShellCommand(self.builder,,command,,d,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
d,=,c.start()
d.addCallback(self._abandonOnFailure)
return,d
def,parseGotRevision(self):
#,using,code,from,tryclient.TlaExtractor
#,'tla,logs,--full',gives,us,ARCHIVE/BRANCH--REVISION
#,'tla,logs',gives,us,REVISION
command,=,[self.vcexe,,"logs",,"--full",,"--reverse"]
c,=,ShellCommand(self.builder,,command,
os.path.join(self.builder.basedir,,self.srcdir),
environ=self.env,
sendStdout=False,,sendStderr=False,,sendRC=False,
keepStdout=True,,usePTY=False)
d,=,c.start()
def,_parse(res):
tid,=,c.stdout.split("\n")[0].strip()
slash,=,tid.index("/")
dd,=,tid.rindex("--")
#branch,=,tid[slash+1:dd]
baserev,=,tid[dd+2:]
return,baserev
d.addCallback(_parse)
return,d
registerSlaveCommand("arch",,Arch,,command_version)
class,Bazaar(Arch):
"""Bazaar,(/usr/bin/baz),is,an,alternative,client,for,Arch,repositories.
It,is,mostly,option-compatible,,but,archive,registration,is,different
enough,to,warrant,a,separate,Command.
['archive'],(required):,the,name,of,the,archive,being,used
"""
def,setup(self,,args):
Arch.setup(self,,args)
self.vcexe,=,getCommand("baz")
#,baz,doesn't,emit,the,repository,name,after,registration,(and
#,grepping,through,the,output,of,'baz,archives',is,too,hard),,so,we
#,require,that,the,buildmaster,configuration,to,provide,both,the
#,archive,name,and,the,URL.
self.archive,=,args['archive'],#,required,for,Baz
self.sourcedata,=,"%s\n%s\n%s\n",%,(self.url,,self.version,
self.buildconfig)
#,in,_didRegister,,the,regexp,won't,match,,so,we'll,stick,with,the,name
#,in,self.archive
def,_doGet(self):
#,baz,prefers,ARCHIVE/VERSION.,This,will,work,even,if
#,my-default-archive,is,not,set.
ver,=,self.archive,+,"/",+,self.version
if,self.revision:
ver,+=,"--%s",%,self.revision
command,=,[self.vcexe,,'get',,'--no-pristine',
ver,,self.srcdir]
c,=,ShellCommand(self.builder,,command,,self.builder.basedir,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
d,=,c.start()
d.addCallback(self._abandonOnFailure)
if,self.buildconfig:
d.addCallback(self._didGet)
return,d
def,parseGotRevision(self):
#,using,code,from,tryclient.BazExtractor
command,=,[self.vcexe,,"tree-id"]
c,=,ShellCommand(self.builder,,command,
os.path.join(self.builder.basedir,,self.srcdir),
environ=self.env,
sendStdout=False,,sendStderr=False,,sendRC=False,
keepStdout=True,,usePTY=False)
d,=,c.start()
def,_parse(res):
tid,=,c.stdout.strip()
slash,=,tid.index("/")
dd,=,tid.rindex("--")
#branch,=,tid[slash+1:dd]
baserev,=,tid[dd+2:]
return,baserev
d.addCallback(_parse)
return,d
registerSlaveCommand("bazaar",,Bazaar,,command_version)
class,Bzr(SourceBase):
"""bzr-specific,VC,operation.,In,addition,to,the,arguments
handled,by,SourceBase,,this,command,reads,the,following,keys:
['repourl'],(required):,the,Bzr,repository,string
"""
header,=,"bzr,operation"
def,setup(self,,args):
SourceBase.setup(self,,args)
self.vcexe,=,getCommand("bzr")
self.repourl,=,args['repourl']
self.sourcedata,=,"%s\n",%,self.repourl
self.revision,=,self.args.get('revision')
def,sourcedirIsUpdateable(self):
if,os.path.exists(os.path.join(self.builder.basedir,
self.srcdir,,".buildbot-patched")):
return,False
if,self.revision:
#,checking,out,a,specific,revision,requires,a,full,'bzr,checkout'
return,False
return,os.path.isdir(os.path.join(self.builder.basedir,
self.srcdir,,".bzr"))
def,doVCUpdate(self):
assert,not,self.revision
#,update:,possible,for,mode,in,('copy',,'update')
srcdir,=,os.path.join(self.builder.basedir,,self.srcdir)
command,=,[self.vcexe,,'update']
c,=,ShellCommand(self.builder,,command,,srcdir,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
return,c.start()
def,doVCFull(self):
#,checkout,or,export
d,=,self.builder.basedir
if,self.mode,==,"export":
#,exporting,in,bzr,requires,a,separate,directory
return,self.doVCExport()
#,originally,I,added,--lightweight,here,,but,then,'bzr,revno',is
#,wrong.,The,revno,reported,in,'bzr,version-info',is,correct,
#,however.,Maybe,this,is,a,bzr,bug?
#
#,In,addition,,you,cannot,perform,a,'bzr,update',on,a,repo,pulled
#,from,an,HTTP,repository,that,used,'bzr,checkout,--lightweight'.,You
#,get,a,"ERROR:,Cannot,lock:,transport,is,read,only",when,you,try.
#
#,So,I,won't,bother,using,--lightweight,for,now.
command,=,[self.vcexe,,'checkout']
if,self.revision:
command.append('--revision')
command.append(str(self.revision))
command.append(self.repourl)
command.append(self.srcdir)
c,=,ShellCommand(self.builder,,command,,d,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
d,=,c.start()
return,d
def,doVCExport(self):
tmpdir,=,os.path.join(self.builder.basedir,,"export-temp")
srcdir,=,os.path.join(self.builder.basedir,,self.srcdir)
command,=,[self.vcexe,,'checkout',,'--lightweight']
if,self.revision:
command.append('--revision')
command.append(str(self.revision))
command.append(self.repourl)
command.append(tmpdir)
c,=,ShellCommand(self.builder,,command,,self.builder.basedir,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
d,=,c.start()
def,_export(res):
command,=,[self.vcexe,,'export',,srcdir]
c,=,ShellCommand(self.builder,,command,,tmpdir,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
return,c.start()
d.addCallback(_export)
return,d
def,get_revision_number(self,,out):
#,it,feels,like,'bzr,revno',sometimes,gives,different,results,than
#,the,'revno:',line,from,'bzr,version-info',,and,the,one,from
#,version-info,is,more,likely,to,be,correct.
for,line,in,out.split("\n"):
colon,=,line.find(":")
if,colon,!=,-1:
key,,value,=,line[:colon],,line[colon+2:]
if,key,==,"revno":
return,int(value)
raise,ValueError("unable,to,find,revno:,in,bzr,output:,'%s'",%,out)
def,parseGotRevision(self):
command,=,[self.vcexe,,"version-info"]
c,=,ShellCommand(self.builder,,command,
os.path.join(self.builder.basedir,,self.srcdir),
environ=self.env,
sendStdout=False,,sendStderr=False,,sendRC=False,
keepStdout=True,,usePTY=False)
d,=,c.start()
def,_parse(res):
try:
return,self.get_revision_number(c.stdout)
except,ValueError:
msg,=("Bzr.parseGotRevision,unable,to,parse,output,"
"of,bzr,version-info:,'%s'",%,c.stdout.strip())
log.msg(msg)
self.sendStatus({'header':,msg,+,"\n"})
return,None
d.addCallback(_parse)
return,d
registerSlaveCommand("bzr",,Bzr,,command_version)
class,Mercurial(SourceBase):
"""Mercurial,specific,VC,operation.,In,addition,to,the,arguments
handled,by,SourceBase,,this,command,reads,the,following,keys:
['repourl'],(required):,the,Cogito,repository,string
"""
header,=,"mercurial,operation"
def,setup(self,,args):
SourceBase.setup(self,,args)
self.vcexe,=,getCommand("hg")
self.repourl,=,args['repourl']
self.sourcedata,=,"%s\n",%,self.repourl
self.stdout,=,""
self.stderr,=,""
def,sourcedirIsUpdateable(self):
if,os.path.exists(os.path.join(self.builder.basedir,
self.srcdir,,".buildbot-patched")):
return,False
#,like,Darcs,,to,check,out,a,specific,(old),revision,,we,have,to,do,a
#,full,checkout.,TODO:,I,think,'hg,pull',plus,'hg,update',might,work
if,self.revision:
return,False
return,os.path.isdir(os.path.join(self.builder.basedir,
self.srcdir,,".hg"))
def,doVCUpdate(self):
d,=,os.path.join(self.builder.basedir,,self.srcdir)
command,=,[self.vcexe,,'pull',,'--verbose',,self.repourl]
c,=,ShellCommand(self.builder,,command,,d,
sendRC=False,,timeout=self.timeout,
keepStdout=True,,usePTY=False)
self.command,=,c
d,=,c.start()
d.addCallback(self._handleEmptyUpdate)
d.addCallback(self._update)
return,d
def,_handleEmptyUpdate(self,,res):
if,type(res),is,int,and,res,==,1:
if,self.command.stdout.find("no,changes,found"),!=,-1:
#,'hg,pull',,when,it,doesn't,have,anything,to,do,,exits,with
#,rc=1,,and,there,appears,to,be,no,way,to,shut,this,off.,It
#,emits,a,distinctive,message,to,stdout,,though.,So,catch
#,this,and,pretend,that,it,completed,successfully.
return,0
return,res
def,doVCFull(self):
d,=,os.path.join(self.builder.basedir,,self.srcdir)
command,=,[self.vcexe,,'init',,d]
c,=,ShellCommand(self.builder,,command,,self.builder.basedir,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
cmd1,=,c.start()
def,_vcupdate(res):
return,self.doVCUpdate()
cmd1.addCallback(_vcupdate)
return,cmd1
def,_update(self,,res):
if,res,!=,0:
return,res
#,compare,current,branch,to,update
self.update_branch,=,self.args.get('branch',,,'default')
d,=,os.path.join(self.builder.basedir,,self.srcdir)
parentscmd,=,[self.vcexe,,'identify',,'--num',,'--branch']
cmd,=,ShellCommand(self.builder,,parentscmd,,d,
sendStdout=False,,sendStderr=False,
keepStdout=True,,keepStderr=True,,usePTY=False)
def,_parse(res):
if,res,!=,0:
msg,=,"'hg,identify',failed:,%s\n%s",%,(cmd.stdout,,cmd.stderr)
self.sendStatus({'header':,msg,+,"\n"})
log.msg(msg)
return,res
log.msg('Output:,%s',%,cmd.stdout)
match,=,re.search(r'^(.+),(.+)$',,cmd.stdout)
assert,match
rev,=,match.group(1)
current_branch,=,match.group(2)
if,rev,==,'-1':
msg,=,"Fresh,hg,repo,,don't,worry,about,branch"
log.msg(msg)
elif,self.update_branch,!=,current_branch:
msg,=,"Working,dir,is,on,branch,'%s',and,build,needs,'%s'.,Clobbering.",%,(current_branch,,self.update_branch)
self.sendStatus({'header':,msg,+,"\n"})
log.msg(msg)
def,_vcfull(res):
return,self.doVCFull()
d,=,self.doClobber(None,,self.srcdir),,,,,,,,,,,,,,,,
d.addCallback(_vcfull)
return,d
else:
msg,=,"Working,dir,on,same,branch,as,build,(%s).",%,(current_branch)
log.msg(msg)
return,0,,,,,,,,,,,,
c,=,cmd.start(),,,,,,,,,,,,,,,,
c.addCallback(_parse)
c.addCallback(self._update2)
return,c
def,_update2(self,,res):,,,,,,,,,,,,,,,,,,,,,,,,
d,=,os.path.join(self.builder.basedir,,self.srcdir)
updatecmd=[self.vcexe,,'update',,'--clean',,'--repository',,d]
if,self.args.get('revision'):
updatecmd.extend(['--rev',,self.args['revision']])
else:
updatecmd.extend(['--rev',,self.args.get('branch',,,'default')])
self.command,=,ShellCommand(self.builder,,updatecmd,
self.builder.basedir,,sendRC=False,
timeout=self.timeout,,usePTY=False)
return,self.command.start()
def,parseGotRevision(self):
#,we,use,'hg,identify',to,find,out,what,we,wound,up,with
command,=,[self.vcexe,,"identify"]
c,=,ShellCommand(self.builder,,command,
os.path.join(self.builder.basedir,,self.srcdir),
environ=self.env,
sendStdout=False,,sendStderr=False,,sendRC=False,
keepStdout=True,,usePTY=False)
d,=,c.start()
def,_parse(res):
m,=,re.search(r'^(\w+)',,c.stdout)
return,m.group(1)
d.addCallback(_parse)
return,d
registerSlaveCommand("hg",,Mercurial,,command_version)
class,P4Base(SourceBase):
"""Base,class,for,P4,source-updaters
['p4port'],(required):,host:port,for,server,to,access
['p4user'],(optional):,user,to,use,for,access
['p4passwd'],(optional):,passwd,to,try,for,the,user
['p4client'],(optional):,client,spec,to,use
"""
def,setup(self,,args):
SourceBase.setup(self,,args)
self.p4port,=,args['p4port']
self.p4client,=,args['p4client']
self.p4user,=,args['p4user']
self.p4passwd,=,args['p4passwd']
def,parseGotRevision(self):
#,Executes,a,p4,command,that,will,give,us,the,latest,changelist,number
#,of,any,file,under,the,current,(or,default),client:
command,=,['p4']
if,self.p4port:
command.extend(['-p',,self.p4port])
if,self.p4user:
command.extend(['-u',,self.p4user])
if,self.p4passwd:
command.extend(['-P',,self.p4passwd])
if,self.p4client:
command.extend(['-c',,self.p4client])
command.extend(['changes',,'-m',,'1',,'#have'])
c,=,ShellCommand(self.builder,,command,,self.builder.basedir,
environ=self.env,,timeout=self.timeout,
sendStdout=True,,sendStderr=False,,sendRC=False,
keepStdout=True,,usePTY=False)
self.command,=,c
d,=,c.start()
def,_parse(res):
#,'p4,-c,clien-name,change,-m,1,"#have"',will,produce,an,output,like:
#,"Change,28147,on,2008/04/07,by,p4user@hostname..."
#,The,number,after,"Change",is,the,one,we,want.
m,=,re.match('Change\s+(\d+)\s+',,c.stdout)
if,m:
return,m.group(1)
return,None
d.addCallback(_parse)
return,d
class,P4(P4Base):
"""A,P4,source-updater.
['p4port'],(required):,host:port,for,server,to,access
['p4user'],(optional):,user,to,use,for,access
['p4passwd'],(optional):,passwd,to,try,for,the,user
['p4client'],(optional):,client,spec,to,use
['p4extra_views'],(optional):,additional,client,views,to,use
"""
header,=,"p4"
def,setup(self,,args):
P4Base.setup(self,,args)
self.p4base,=,args['p4base']
self.p4extra_views,=,args['p4extra_views']
self.p4mode,=,args['mode']
self.p4branch,=,args['branch']
self.sourcedata,=,str([
#,Perforce,server.
self.p4port,
#,Client,spec.
self.p4client,
#,Depot,side,of,view,spec.
self.p4base,
self.p4branch,
self.p4extra_views,
#,Local,side,of,view,spec,(srcdir,is,made,from,these).
self.builder.basedir,
self.mode,
self.workdir
])
def,sourcedirIsUpdateable(self):
if,os.path.exists(os.path.join(self.builder.basedir,
self.srcdir,,".buildbot-patched")):
return,False
#,We,assume,our,client,spec,is,still,around.
#,We,just,say,we,aren't,updateable,if,the,dir,doesn't,exist,so,we
#,don't,get,ENOENT,checking,the,sourcedata.
return,os.path.isdir(os.path.join(self.builder.basedir,
self.srcdir))
def,doVCUpdate(self):
return,self._doP4Sync(force=False)
def,_doP4Sync(self,,force):
command,=,['p4']
if,self.p4port:
command.extend(['-p',,self.p4port])
if,self.p4user:
command.extend(['-u',,self.p4user])
if,self.p4passwd:
command.extend(['-P',,self.p4passwd])
if,self.p4client:
command.extend(['-c',,self.p4client])
command.extend(['sync'])
if,force:
command.extend(['-f'])
if,self.revision:
command.extend(['@',+,str(self.revision)])
env,=,{}
c,=,ShellCommand(self.builder,,command,,self.builder.basedir,
environ=env,,sendRC=False,,timeout=self.timeout,
keepStdout=True,,usePTY=False)
self.command,=,c
d,=,c.start()
d.addCallback(self._abandonOnFailure)
return,d
def,doVCFull(self):
env,=,{}
command,=,['p4']
client_spec,=,''
client_spec,+=,"Client:,%s\n\n",%,self.p4client
client_spec,+=,"Owner:,%s\n\n",%,self.p4user
client_spec,+=,"Description:\n\tCreated,by,%s\n\n",%,self.p4user
client_spec,+=,"Root:\t%s\n\n",%,self.builder.basedir
client_spec,+=,"Options:\tallwrite,rmdir\n\n"
client_spec,+=,"LineEnd:\tlocal\n\n"
#,Setup,a,view
client_spec,+=,"View:\n\t%s",%,(self.p4base)
if,self.p4branch:
client_spec,+=,"%s/",%,(self.p4branch)
client_spec,+=,"...,//%s/%s/...\n",%,(self.p4client,,self.srcdir)
if,self.p4extra_views:
for,k,,v,in,self.p4extra_views:
client_spec,+=,"\t%s/...,//%s/%s%s/...\n",%,(k,,self.p4client,
self.srcdir,,v)
if,self.p4port:
command.extend(['-p',,self.p4port])
if,self.p4user:
command.extend(['-u',,self.p4user])
if,self.p4passwd:
command.extend(['-P',,self.p4passwd])
command.extend(['client',,'-i'])
log.msg(client_spec)
c,=,ShellCommand(self.builder,,command,,self.builder.basedir,
environ=env,,sendRC=False,,timeout=self.timeout,
initialStdin=client_spec,,usePTY=False)
self.command,=,c
d,=,c.start()
d.addCallback(self._abandonOnFailure)
d.addCallback(lambda,_:,self._doP4Sync(force=True))
return,d
registerSlaveCommand("p4",,P4,,command_version)
class,P4Sync(P4Base):
"""A,partial,P4,source-updater.,Requires,manual,setup,of,a,per-slave,P4
environment.,The,only,thing,which,comes,from,the,master,is,P4PORT.
'mode',is,required,to,be,'copy'.
['p4port'],(required):,host:port,for,server,to,access
['p4user'],(optional):,user,to,use,for,access
['p4passwd'],(optional):,passwd,to,try,for,the,user
['p4client'],(optional):,client,spec,to,use
"""
header,=,"p4,sync"
def,setup(self,,args):
P4Base.setup(self,,args)
self.vcexe,=,getCommand("p4")
def,sourcedirIsUpdateable(self):
return,True
def,_doVC(self,,force):
d,=,os.path.join(self.builder.basedir,,self.srcdir)
command,=,[self.vcexe]
if,self.p4port:
command.extend(['-p',,self.p4port])
if,self.p4user:
command.extend(['-u',,self.p4user])
if,self.p4passwd:
command.extend(['-P',,self.p4passwd])
if,self.p4client:
command.extend(['-c',,self.p4client])
command.extend(['sync'])
if,force:
command.extend(['-f'])
if,self.revision:
command.extend(['@',+,self.revision])
env,=,{}
c,=,ShellCommand(self.builder,,command,,d,,environ=env,
sendRC=False,,timeout=self.timeout,,usePTY=False)
self.command,=,c
return,c.start()
def,doVCUpdate(self):
return,self._doVC(force=False)
def,doVCFull(self):
return,self._doVC(force=True)
registerSlaveCommand("p4sync",,P4Sync,,command_version)
#,This,Source,Code,Form,is,subject,to,the,terms,of,the,Mozilla,Public
#,License,,v.,2.0.,If,a,copy,of,the,MPL,was,not,distributed,with,this
#,file,,You,can,obtain,one,at,http://mozilla.org/MPL/2.0/.
import,urlparse,,urllib,,time
from,zope.interface,import,Interface
from,twisted.web,import,html,,resource
from,buildbot.status,import,builder
from,buildbot.status.builder,import,SUCCESS,,WARNINGS,,FAILURE,,SKIPPED,,EXCEPTION
from,buildbot,import,version,,util
class,ITopBox(Interface):
"""I,represent,a,box,in,the,top,row,of,the,waterfall,display:,the,one
which,shows,the,status,of,the,last,build,for,each,builder."""
def,getBox(self,,request):
"""Return,a,Box,instance,,which,can,produce,a,<td>,cell.
"""
class,ICurrentBox(Interface):
"""I,represent,the,'current,activity',box,,just,above,the,builder,name."""
def,getBox(self,,status):
"""Return,a,Box,instance,,which,can,produce,a,<td>,cell.
"""
class,IBox(Interface):
"""I,represent,a,box,in,the,waterfall,display."""
def,getBox(self,,request):
"""Return,a,Box,instance,,which,wraps,an,Event,and,can,produce,a,<td>
cell.
"""
class,IHTMLLog(Interface):
pass
css_classes,=,{SUCCESS:,"success",
WARNINGS:,"warnings",
FAILURE:,"failure",
SKIPPED:,"skipped",
EXCEPTION:,"exception",
}
ROW_TEMPLATE,=,'''
<div,class="row">
<span,class="label">%(label)s</span>
<span,class="field">%(field)s</span>
</div>
'''
def,make_row(label,,field):
"""Create,a,name/value,row,for,the,HTML.
`label`,is,plain,text,;,it,will,be,HTML-encoded.
`field`,is,a,bit,of,HTML,structure,;,it,will,not,be,encoded,in
any,way.
"""
label,=,html.escape(label)
return,ROW_TEMPLATE,%,{"label":,label,,"field":,field}
def,make_stop_form(stopURL,,on_all=False,,label="Build"):
if,on_all:
data,=,"""<form,action="%s",class='command,stopbuild'>
<p>To,stop,all,builds,,fill,out,the,following,fields,and
push,the,'Stop',button</p>\n""",%,stopURL
else:
data,=,"""<form,action="%s",class='command,stopbuild'>
<p>To,stop,this,build,,fill,out,the,following,fields,and
push,the,'Stop',button</p>\n""",%,stopURL
data,+=,make_row("Your,name:",
"<input,type='text',name='username',/>")
data,+=,make_row("Reason,for,stopping,build:",
"<input,type='text',name='comments',/>")
data,+=,'<input,type="submit",value="Stop,%s",/></form>\n',%,label
return,data
def,make_force_build_form(forceURL,,on_all=False):
if,on_all:
data,=,"""<form,action="%s",class="command,forcebuild">
<p>To,force,a,build,on,all,Builders,,fill,out,the,following,fields
and,push,the,'Force,Build',button</p>""",%,forceURL
else:
data,=,"""<form,action="%s",class="command,forcebuild">
<p>To,force,a,build,,fill,out,the,following,fields,and
push,the,'Force,Build',button</p>""",%,forceURL
return,(data
+,make_row("Your,name:",
"<input,type='text',name='username',/>")
+,make_row("Reason,for,build:",
"<input,type='text',name='comments',/>")
+,make_row("Branch,to,build:",
"<input,type='text',name='branch',/>")
+,make_row("Revision,to,build:",
"<input,type='text',name='revision',/>")
+,'<input,type="submit",value="Force,Build",/></form>\n')
def,td(text="",,parms={},,**props):
data,=,""
data,+=,",,"
#if,not,props.has_key("border"):
#,,,,props["border"],=,1
props.update(parms)
comment,=,props.get("comment",,None)
if,comment:
data,+=,"<!--,%s,-->",%,comment
data,+=,"<td"
class_,=,props.get('class_',,None)
if,class_:
props["class"],=,class_
for,prop,in,("align",,"colspan",,"rowspan",,"border",
"valign",,"halign",,"class"):
p,=,props.get(prop,,None)
if,p,!=,None:
data,+=,",%s=\"%s\"",%,(prop,,p)
data,+=,">"
if,not,text:
text,=,"&nbsp,;"
if,isinstance(text,,list):
data,+=,"<br,/>".join(text)
else:
data,+=,text
data,+=,"</td>\n"
return,data
def,build_get_class(b):
"""
Return,the,class,to,use,for,a,finished,build,or,buildstep,
based,on,the,result.
"""
#,FIXME:,this,getResults,duplicity,might,need,to,be,fixed
result,=,b.getResults()
#print,"THOMAS:,result,for,b,%r:,%r",%,(b,,result)
if,isinstance(b,,builder.BuildStatus):
result,=,b.getResults()
elif,isinstance(b,,builder.BuildStepStatus):
result,=,b.getResults()[0]
#,after,forcing,a,build,,b.getResults(),returns,((None,,[]),,[]),,ugh
if,isinstance(result,,tuple):
result,=,result[0]
else:
raise,TypeError,,"%r,is,not,a,BuildStatus,or,BuildStepStatus",%,b
if,result,==,None:
#,FIXME:,this,happens,when,a,buildstep,is,running,?
return,"running"
return,builder.Results[result]
def,path_to_root(request):
#,/waterfall,:,['waterfall'],->,''
#,/somewhere/lower,:,['somewhere',,'lower'],->,'../'
#,/somewhere/indexy/,:,['somewhere',,'indexy',,''],->,'../../'
#,/,:,[],->,''
if,request.prepath:
segs,=,len(request.prepath),-,1
else:
segs,=,0
root,=,"../",*,segs
return,root
def,path_to_builder(request,,builderstatus):
return,(path_to_root(request),+
"builders/",+
urllib.quote(builderstatus.getName(),,safe=''))
def,path_to_build(request,,buildstatus):
return,(path_to_builder(request,,buildstatus.getBuilder()),+
"/builds/%d",%,buildstatus.getNumber())
def,path_to_step(request,,stepstatus):
return,(path_to_build(request,,stepstatus.getBuild()),+
"/steps/%s",%,urllib.quote(stepstatus.getName(),,safe=''))
def,path_to_slave(request,,slave):
return,(path_to_root(request),+
"buildslaves/",+
urllib.quote(slave.getName(),,safe=''))
class,Box:
#,a,Box,wraps,an,Event.,The,Box,has,HTML,<td>,parameters,that,Events
#,lack,,and,it,has,a,base,URL,to,which,each,File's,name,is,relative.
#,Events,don't,know,about,HTML.
spacer,=,False
def,__init__(self,,text=[],,class_=None,,urlbase=None,
**parms):
self.text,=,text
self.class_,=,class_
self.urlbase,=,urlbase
self.show_idle,=,0
if,parms.has_key('show_idle'):
del,parms['show_idle']
self.show_idle,=,1
self.parms,=,parms
#,parms,is,a,dict,of,HTML,parameters,for,the,<td>,element,that,will
#,represent,this,Event,in,the,waterfall,display.
def,td(self,,**props):
props.update(self.parms)
text,=,self.text
if,not,text,and,self.show_idle:
text,=,["[idle]"]
return,td(text,,props,,class_=self.class_)
class,HtmlResource(resource.Resource):
#,this,is,a,cheap,sort,of,template,thingy
contentType,=,"text/html,;,charset=UTF-8"
title,=,"Buildbot"
addSlash,=,False,#,adapted,from,Nevow
def,getChild(self,,path,,request):
if,self.addSlash,and,path,==,"",and,len(request.postpath),==,0:
return,self
return,resource.Resource.getChild(self,,path,,request)
def,render(self,,request):
#,tell,the,WebStatus,about,the,HTTPChannel,that,got,opened,,so,they
#,can,close,it,if,we,get,reconfigured,and,the,WebStatus,goes,away.
#,They,keep,a,weakref,to,this,,since,chances,are,good,that,it,will,be
#,closed,by,the,browser,or,by,us,before,we,get,reconfigured.,See
#,ticket,#102,for,details.
if,hasattr(request,,"channel"):
#,web.distrib.Request,has,no,.channel
request.site.buildbot_service.registerChannel(request.channel)
#,Our,pages,no,longer,require,that,their,URL,end,in,a,slash.,Instead,
#,they,all,use,request.childLink(),or,some,equivalent,which,takes,the
#,last,path,component,into,account.,This,clause,is,left,here,for
#,historical,and,educational,purposes.
if,False,and,self.addSlash,and,request.prepath[-1],!=,'':
#,this,is,intended,to,behave,like,request.URLPath().child('')
#,but,we,need,a,relative,URL,,since,we,might,be,living,behind,a
#,reverse,proxy
#
#,note,that,the,Location:,header,(as,used,in,redirects),are
#,required,to,have,absolute,URIs,,and,my,attempt,to,handle
#,reverse-proxies,gracefully,violates,rfc2616.,This,frequently
#,works,,but,single-component,paths,sometimes,break.,The,best
#,strategy,is,to,avoid,these,redirects,whenever,possible,by,using
#,HREFs,with,trailing,slashes,,and,only,use,the,redirects,for
#,manually,entered,URLs.
url,=,request.prePathURL()
scheme,,netloc,,path,,query,,fragment,=,urlparse.urlsplit(url)
new_url,=,request.prepath[-1],+,"/"
if,query:
new_url,+=,"?",+,query
request.redirect(new_url)
return,''
data,=,self.content(request)
if,isinstance(data,,unicode):
data,=,data.encode("utf-8")
request.setHeader("content-type",,self.contentType)
if,request.method,==,"HEAD":
request.setHeader("content-length",,len(data))
return,''
return,data
def,getStatus(self,,request):
return,request.site.buildbot_service.getStatus()
def,getControl(self,,request):
return,request.site.buildbot_service.getControl()
def,getChangemaster(self,,request):
return,request.site.buildbot_service.getChangeSvc()
def,path_to_root(self,,request):
return,path_to_root(request)
def,footer(self,,s,,req):
#,TODO:,this,stuff,should,be,generated,by,a,template,of,some,sort
projectURL,=,s.getProjectURL()
projectName,=,s.getProjectName()
data,=,'<hr,/><div,class="footer">\n'
welcomeurl,=,self.path_to_root(req),+,"index.html"
data,+=,'[<a,href="%s">welcome</a>]\n',%,welcomeurl
data,+=,"<br,/>\n"
data,+=,'<a,href="http://buildbot.sourceforge.net/">Buildbot</a>'
data,+=,"-%s,",%,version
if,projectName:
data,+=,"working,for,the,"
if,projectURL:
data,+=,"<a,href=\"%s\">%s</a>,project.",%,(projectURL,
projectName)
else:
data,+=,"%s,project.",%,projectName
data,+=,"<br,/>\n"
data,+=,("Page,built:,",+
time.strftime("%a,%d,%b,%Y,%H:%M:%S",
time.localtime(util.now()))
+,"\n")
data,+=,'</div>\n'
return,data
def,getTitle(self,,request):
return,self.title
def,fillTemplate(self,,template,,request):
s,=,request.site.buildbot_service
values,=,s.template_values.copy()
values['root'],=,self.path_to_root(request)
#,e.g.,to,reference,the,top-level,'buildbot.css',page,,use
#,"%(root)sbuildbot.css"
values['title'],=,self.getTitle(request)
return,template,%,values
def,content(self,,request):
s,=,request.site.buildbot_service
data,=,""
data,+=,self.fillTemplate(s.header,,request)
data,+=,"<head>\n"
for,he,in,s.head_elements:
data,+=,",",+,self.fillTemplate(he,,request),+,"\n"
data,+=,self.head(request)
data,+=,"</head>\n\n"
data,+=,'<body,%s>\n',%,",".join(['%s="%s"',%,(k,v)
for,(k,v),in,s.body_attrs.items()])
data,+=,self.body(request)
data,+=,"</body>\n"
data,+=,self.fillTemplate(s.footer,,request)
return,data
def,head(self,,request):
return,""
def,body(self,,request):
return,"Dummy\n"
class,StaticHTML(HtmlResource):
def,__init__(self,,body,,title):
HtmlResource.__init__(self)
self.bodyHTML,=,body
self.title,=,title
def,body(self,,request):
return,self.bodyHTML
MINUTE,=,60
HOUR,=,60*MINUTE
DAY,=,24*HOUR
WEEK,=,7*DAY
MONTH,=,30*DAY
def,plural(word,,words,,num):
if,int(num),==,1:
return,"%d,%s",%,(num,,word)
else:
return,"%d,%s",%,(num,,words)
def,abbreviate_age(age):
if,age,<=,90:
return,"%s,ago",%,plural("second",,"seconds",,age)
if,age,<,90*MINUTE:
return,"about,%s,ago",%,plural("minute",,"minutes",,age,/,MINUTE)
if,age,<,DAY:
return,"about,%s,ago",%,plural("hour",,"hours",,age,/,HOUR)
if,age,<,2*WEEK:
return,"about,%s,ago",%,plural("day",,"days",,age,/,DAY)
if,age,<,2*MONTH:
return,"about,%s,ago",%,plural("week",,"weeks",,age,/,WEEK)
return,"a,long,time,ago"
class,OneLineMixin:
LINE_TIME_FORMAT,=,"%b,%d,%H:%M"
def,get_line_values(self,,req,,build):
'''
Collect,the,data,needed,for,each,line,display
'''
builder_name,=,build.getBuilder().getName()
results,=,build.getResults()
text,=,build.getText()
try:
revision=build.getSourceStamp().revision
if,(len(build.changes)>0):
rev,=,build.changes[0].revision
if,(revision):
rev,=,revision
if,rev,is,None:
rev,=,"??"
except,KeyError:
rev,=,"??"
rev,=,str(rev)
if,len(rev),>,40:
rev,=,"version,is,too-long"
root,=,self.path_to_root(req)
css_class,=,css_classes.get(results,,"")
values,=,{'class':,css_class,
'builder_name':,builder_name,
'buildnum':,build.getNumber(),
'results':,css_class,
'text':,",".join(build.getText()),
'buildurl':,path_to_build(req,,build),
'builderurl':,path_to_builder(req,,build.getBuilder()),
'rev':,rev,
'time':,time.strftime(self.LINE_TIME_FORMAT,
time.localtime(build.getTimes()[0])),
}
return,values
def,make_line(self,,req,,build,,include_builder=True):
'''
Format,and,render,a,single,line,into,HTML
'''
values,=,self.get_line_values(req,,build)
fmt_pieces,=,['<font,size="-1">(%(time)s)</font>',
'rev=[%(rev)s]',
'<span,class="%(class)s">%(results)s</span>',
]
if,include_builder:
fmt_pieces.append('<a,href="%(builderurl)s">%(builder_name)s</a>')
fmt_pieces.append('<a,href="%(buildurl)s">#%(buildnum)d</a>:')
fmt_pieces.append('%(text)s')
data,=,",".join(fmt_pieces),%,values
return,data
def,map_branches(branches):
#,when,the,query,args,say,"trunk",,present,that,to,things,like
#,IBuilderStatus.generateFinishedBuilds,as,None,,since,that's,the
#,convention,in,use.,But,also,include,'trunk',,because,some,VC,systems
#,refer,to,it,that,way.,In,the,long,run,we,should,clean,this,up,better,
#,maybe,with,Branch,objects,or,something.
if,"trunk",in,branches:
return,branches,+,[None]
return,branches
#,This,Source,Code,Form,is,subject,to,the,terms,of,the,Mozilla,Public
#,License,,v.,2.0.,If,a,copy,of,the,MPL,was,not,distributed,with,this
#,file,,You,can,obtain,one,at,http://mozilla.org/MPL/2.0/.
import,os,,sys,,urllib,,weakref
from,itertools,import,count
from,zope.interface,import,implements
from,twisted.python,import,log
from,twisted.application,import,strports,,service
from,twisted.web,import,server,,distrib,,static,,html
from,twisted.spread,import,pb
from,buildbot.interfaces,import,IControl,,IStatusReceiver
from,buildbot.status.web.base,import,HtmlResource,,Box,,\
build_get_class,,ICurrentBox,,OneLineMixin,,map_branches,,\
make_stop_form,,make_force_build_form
from,buildbot.status.web.base,import,*
from,buildbot.status.web.feeds,import,Rss20StatusResource,,\
Atom10StatusResource
from,buildbot.status.web.waterfall,import,WaterfallStatusResource
from,buildbot.status.web.grid,import,GridStatusResource
from,buildbot.status.web.changes,import,ChangesResource
from,buildbot.status.web.builder,import,BuildersResource
from,buildbot.status.web.slaves,import,BuildSlavesResource
from,buildbot.status.web.xmlrpc,import,XMLRPCServer
from,buildbot.status.web.about,import,AboutBuildbot
#,this,class,contains,the,status,services,(WebStatus,and,the,older,Waterfall)
#,which,can,be,put,in,c['status'].,It,also,contains,some,of,the,resources
#,that,are,attached,to,the,WebStatus,at,various,well-known,URLs,,which,the
#,admin,might,wish,to,attach,(using,WebStatus.putChild),at,other,URLs.
class,LastBuild(HtmlResource):
def,body(self,,request):
return,"missing\n"
def,getLastNBuilds(status,,numbuilds,,builders=[],,branches=[]):
"""Return,a,list,with,the,last,few,Builds,,sorted,by,start,time.
builder_names=None,means,all,builders
"""
#,TODO:,this,unsorts,the,list,of,builder,names,,ick
builder_names,=,set(status.getBuilderNames())
if,builders:
builder_names,=,builder_names.intersection(set(builders))
#,to,make,sure,that,we,get,everything,,we,must,get,'numbuilds',builds
#,from,*each*,source,,then,sort,by,ending,time,,then,trim,to,the,last
#,20.,We,could,be,more,efficient,,but,it,would,require,the,same
#,gnarly,code,that,the,Waterfall,uses,to,generate,one,event,at,a
#,time.,TODO:,factor,that,code,out,into,some,useful,class.
events,=,[]
for,builder_name,in,builder_names:
builder,=,status.getBuilder(builder_name)
for,build_number,in,count(1):
if,build_number,>,numbuilds:
break,#,enough,from,this,builder,,move,on,to,another
build,=,builder.getBuild(-build_number)
if,not,build:
break,#,no,more,builds,here,,move,on,to,the,next,builder
#if,not,build.isFinished():
#,,,,continue
(build_start,,build_end),=,build.getTimes()
event,=,(build_start,,builder_name,,build)
events.append(event)
def,_sorter(a,,b):
return,cmp(,a[:2],,b[:2],)
events.sort(_sorter)
#,now,only,return,the,actual,build,,and,only,return,some,of,them
return,[e[2],for,e,in,events[-numbuilds:]]
#,/one_line_per_build
#,,accepts,builder=,,branch=,,numbuilds=
class,OneLinePerBuild(HtmlResource,,OneLineMixin):
"""This,shows,one,line,per,build,,combining,all,builders,together.,Useful
query,arguments:
numbuilds=:,how,many,lines,to,display
builder=:,show,only,builds,for,this,builder.,Multiple,builder=,arguments
can,be,used,to,see,builds,from,any,builder,in,the,set.
"""
title,=,"Recent,Builds"
def,__init__(self,,numbuilds=20):
HtmlResource.__init__(self)
self.numbuilds,=,numbuilds
def,getChild(self,,path,,req):
status,=,self.getStatus(req)
builder,=,status.getBuilder(path)
return,OneLinePerBuildOneBuilder(builder)
def,body(self,,req):
status,=,self.getStatus(req)
control,=,self.getControl(req)
numbuilds,=,int(req.args.get("numbuilds",,[self.numbuilds])[0])
builders,=,req.args.get("builder",,[])
branches,=,[b,for,b,in,req.args.get("branch",,[]),if,b]
g,=,status.generateFinishedBuilds(builders,,map_branches(branches),
numbuilds)
data,=,""
#,really,this,is,"up,to,%d,builds"
data,+=,"<h1>Last,%d,finished,builds:,%s</h1>\n",%,\
(numbuilds,,",,".join(branches))
if,builders:
data,+=,("<p>of,builders:,%s</p>\n",%,(",,".join(builders)))
data,+=,"<ul>\n"
got,=,0
building,=,False
online,=,0
for,build,in,g:
got,+=,1
data,+=,",<li>",+,self.make_line(req,,build),+,"</li>\n"
builder_status,=,build.getBuilder().getState()[0]
if,builder_status,==,"building":
building,=,True
online,+=,1
elif,builder_status,!=,"offline":
online,+=,1
if,not,got:
data,+=,",<li>No,matching,builds,found</li>\n"
data,+=,"</ul>\n"
if,control,is,not,None:
if,building:
stopURL,=,"builders/_all/stop"
data,+=,make_stop_form(stopURL,,True,,"Builds")
if,online:
forceURL,=,"builders/_all/force"
data,+=,make_force_build_form(forceURL,,True)
return,data
#,/one_line_per_build/$BUILDERNAME
#,,accepts,branch=,,numbuilds=
class,OneLinePerBuildOneBuilder(HtmlResource,,OneLineMixin):
def,__init__(self,,builder,,numbuilds=20):
HtmlResource.__init__(self)
self.builder,=,builder
self.builder_name,=,builder.getName()
self.numbuilds,=,numbuilds
self.title,=,"Recent,Builds,of,%s",%,self.builder_name
def,body(self,,req):
status,=,self.getStatus(req)
numbuilds,=,int(req.args.get("numbuilds",,[self.numbuilds])[0])
branches,=,[b,for,b,in,req.args.get("branch",,[]),if,b]
#,walk,backwards,through,all,builds,of,a,single,builder
g,=,self.builder.generateFinishedBuilds(map_branches(branches),
numbuilds)
data,=,""
data,+=,("<h1>Last,%d,builds,of,builder,%s:,%s</h1>\n",%
(numbuilds,,self.builder_name,,",,".join(branches)))
data,+=,"<ul>\n"
got,=,0
for,build,in,g:
got,+=,1
data,+=,",<li>",+,self.make_line(req,,build),+,"</li>\n"
if,not,got:
data,+=,",<li>No,matching,builds,found</li>\n"
data,+=,"</ul>\n"
return,data
#,/one_box_per_builder
#,,accepts,builder=,,branch=
class,OneBoxPerBuilder(HtmlResource):
"""This,shows,a,narrow,table,with,one,row,per,builder.,The,leftmost,column
contains,the,builder,name.,The,next,column,contains,the,results,of,the
most,recent,build.,The,right-hand,column,shows,the,builder's,current
activity.
builder=:,show,only,builds,for,this,builder.,Multiple,builder=,arguments
can,be,used,to,see,builds,from,any,builder,in,the,set.
"""
title,=,"Latest,Build"
def,body(self,,req):
status,=,self.getStatus(req)
control,=,self.getControl(req)
builders,=,req.args.get("builder",,status.getBuilderNames())
branches,=,[b,for,b,in,req.args.get("branch",,[]),if,b]
data,=,""
data,+=,"<h2>Latest,builds:,%s</h2>\n",%,",,".join(branches)
data,+=,"<table>\n"
building,=,False
online,=,0
base_builders_url,=,self.path_to_root(req),+,"builders/"
for,bn,in,builders:
base_builder_url,=,base_builders_url,+,urllib.quote(bn,,safe='')
builder,=,status.getBuilder(bn)
data,+=,"<tr>\n"
data,+=,'<td,class="box"><a,href="%s">%s</a></td>\n',\
%,(base_builder_url,,html.escape(bn))
builds,=,list(builder.generateFinishedBuilds(map_branches(branches),
num_builds=1))
if,builds:
b,=,builds[0]
url,=,(base_builder_url,+,"/builds/%d",%,b.getNumber())
try:
revision=b.getSourceStamp().revision
if,(len(b.changes)>0):
label,=,b.changes[0].revision
if,(revision):
label,=,revision
except,KeyError:
label,=,None
if,not,label,or,len(str(label)),>,20:
label,=,"#%d",%,b.getNumber()
text,=,['<a,href="%s">%s</a>',%,(url,,label)]
text.extend(b.getText())
box,=,Box(text,
class_="LastBuild,box,%s",%,build_get_class(b))
data,+=,box.td(align="center")
else:
data,+=,'<td,class="LastBuild,box",>no,build</td>\n'
current_box,=,ICurrentBox(builder).getBox(status)
data,+=,current_box.td(align="center")
builder_status,=,builder.getState()[0]
if,builder_status,==,"building":
building,=,True
online,+=,1
elif,builder_status,!=,"offline":
online,+=,1
data,+=,"</table>\n"
if,control,is,not,None:
if,building:
stopURL,=,"builders/_all/stop"
data,+=,make_stop_form(stopURL,,True,,"Builds")
if,online:
forceURL,=,"builders/_all/force"
data,+=,make_force_build_form(forceURL,,True)
return,data
class,HorizontalOneBoxPerBuilder(HtmlResource):
"""This,shows,a,table,with,one,cell,per,build.,The,color,of,the,cell,is
the,state,of,the,most,recently,completed,build.,If,there,is,a,build,in
progress,,the,ETA,is,shown,in,table,cell.,The,table,cell,links,to,the,page
for,that,builder.,They,are,layed,out,,you,guessed,it,,horizontally.
builder=:,show,only,builds,for,this,builder.,Multiple,builder=,arguments
can,be,used,to,see,builds,from,any,builder,in,the,set.,If,no
builder=,is,given,,shows,them,all.
"""
def,body(self,,request):
status,=,self.getStatus(request)
builders,=,request.args.get("builder",,status.getBuilderNames())
data,=,"<table,style='width:100%'><tr>"
for,builder_name,in,builders:
builder,=,status.getBuilder(builder_name)
if,builder.getState()[0],==,'building':
classname,=,'LastBuild,running'
else:,
classname,=,ITopBox(builder).getBox(request).class_
title,=,builder_name
url,=,(self.path_to_root(request),+,"waterfall?builder=",+
urllib.quote(builder_name,,safe=''))
link,=,'<a,href="%s",class="%s",title="%s",\
target=_blank>,</a>',%,(url,,classname,,title)
data,+=,'<td,valign=bottom,class=mini-box>%s</td>',%,link
data,+=,"</tr></table>"
return,data
HEADER,=,'''
<!DOCTYPE,html,PUBLIC,"-//W3C//DTD,XHTML,1.0,Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
xmlns="http://www.w3.org/1999/xhtml"
lang="en"
xml:lang="en">
'''
HEAD_ELEMENTS,=,[
'<title>%(title)s</title>',
'<link,href="%(root)sbuildbot.css",rel="stylesheet",type="text/css",/>',
]
BODY_ATTRS,=,{
'vlink':,"#800080",
}
FOOTER,=,'''
</html>
'''
class,WebStatus(service.MultiService):
implements(IStatusReceiver)
#,TODO:,IStatusReceiver,is,really,about,things,which,subscribe,to,hear
#,about,buildbot,events.,We,need,a,different,interface,(perhaps,a,parent
#,of,IStatusReceiver),for,status,targets,that,don't,subscribe,,like,the
#,WebStatus,class.,buildbot.master.BuildMaster.loadConfig:737,asserts
#,that,everything,in,c['status'],provides,IStatusReceiver,,but,really,it
#,should,check,that,they,provide,IStatusTarget,instead.
"""
The,webserver,provided,by,this,class,has,the,following,resources:
/waterfall,:,the,big,time-oriented,'waterfall',display,,with,links
to,individual,changes,,builders,,builds,,steps,,and,logs.
A,number,of,query-arguments,can,be,added,to,influence
the,display.
/rss,:,a,rss,feed,summarizing,all,failed,builds.,The,same
query-arguments,used,by,'waterfall',can,be,added,to
influence,the,feed,output.
/atom,:,an,atom,feed,summarizing,all,failed,builds.,The,same
query-arguments,used,by,'waterfall',can,be,added,to
influence,the,feed,output.
/grid,:,another,summary,display,that,shows,a,grid,of,builds,,with
sourcestamps,on,the,x,axis,,and,builders,on,the,y.,,Query,
arguments,similar,to,those,for,the,waterfall,can,be,added.
/builders/BUILDERNAME:,a,page,summarizing,the,builder.,This,includes
references,to,the,Schedulers,that,feed,it,
any,builds,currently,in,the,queue,,which
buildslaves,are,designated,or,attached,,and,a
summary,of,the,build,process,it,uses.
/builders/BUILDERNAME/builds/NUM:,a,page,describing,a,single,Build
/builders/BUILDERNAME/builds/NUM/steps/STEPNAME:,describes,a,single,step
/builders/BUILDERNAME/builds/NUM/steps/STEPNAME/logs/LOGNAME:,a,StatusLog
/builders/BUILDERNAME/builds/NUM/tests,:,summarize,test,results
/builders/BUILDERNAME/builds/NUM/tests/TEST.NAME:,results,of,one,test
/builders/_all/{force,stop}:,force,a,build/stop,building,on,all,builders.
/changes,:,summarize,all,ChangeSources
/changes/CHANGENUM:,a,page,describing,a,single,Change
/schedulers/SCHEDULERNAME:,a,page,describing,a,Scheduler,,including
a,description,of,its,behavior,,a,list,of,the
Builders,it,triggers,,and,list,of,the,Changes
that,are,queued,awaiting,the,tree-stable
timer,,and,controls,to,accelerate,the,timer.
/buildslaves,:,list,all,BuildSlaves
/buildslaves/SLAVENAME,:,describe,a,single,BuildSlave
/one_line_per_build,:,summarize,the,last,few,builds,,one,line,each
/one_line_per_build/BUILDERNAME,:,same,,but,only,for,a,single,builder
/one_box_per_builder,:,show,the,latest,build,and,current,activity
/about,:,describe,this,buildmaster,(Buildbot,and,support,library,versions)
/xmlrpc,:,(not,yet,implemented),an,XMLRPC,server,with,build,status
All,URLs,for,pages,which,are,not,defined,here,are,used,to,look
for,files,in,PUBLIC_HTML,,which,defaults,to,BASEDIR/public_html.
This,means,that,/robots.txt,or,/buildbot.css,or,/favicon.ico,can
be,placed,in,that,directory.
If,an,index,file,(index.html,,index.htm,,or,index,,in,that,order),is
present,in,PUBLIC_HTML,,it,will,be,used,for,the,root,resource.,If,not,
the,default,behavior,is,to,put,a,redirection,to,the,/waterfall,page.
All,of,the,resources,provided,by,this,service,use,relative,URLs,to,reach
each,other.,The,only,absolute,links,are,the,c['projectURL'],links,at,the
top,and,bottom,of,the,page,,and,the,buildbot,home-page,link,at,the
bottom.
This,webserver,defines,class,attributes,on,elements,so,they,can,be,styled
with,CSS,stylesheets.,All,pages,pull,in,PUBLIC_HTML/buildbot.css,,and,you
can,cause,additional,stylesheets,to,be,loaded,by,adding,a,suitable,<link>
to,the,WebStatus,instance's,.head_elements,attribute.
Buildbot,uses,some,generic,classes,to,identify,the,type,of,object,,and
some,more,specific,classes,for,the,various,kinds,of,those,types.,It,does
this,by,specifying,both,in,the,class,attributes,where,applicable,
separated,by,a,space.,It,is,important,that,in,your,CSS,you,declare,the
more,generic,class,styles,above,the,more,specific,ones.,For,example,
first,define,a,style,for,.Event,,and,below,that,for,.SUCCESS
The,following,CSS,class,names,are,used:
-,Activity,,Event,,BuildStep,,LastBuild:,general,classes
-,waiting,,interlocked,,building,,offline,,idle:,Activity,states
-,start,,running,,success,,failure,,warnings,,skipped,,exception:
LastBuild,and,BuildStep,states
-,Change:,box,with,change
-,Builder:,box,for,builder,name,(at,top)
-,Project
-,Time
"""
#,we,are,not,a,ComparableMixin,,and,therefore,the,webserver,will,be
#,rebuilt,every,time,we,reconfig.,This,is,because,WebStatus.putChild()
#,makes,it,too,difficult,to,tell,whether,two,instances,are,the,same,or
#,not,(we'd,have,to,do,a,recursive,traversal,of,all,children,to,discover
#,all,the,changes).
def,__init__(self,,http_port=None,,distrib_port=None,,allowForce=False,
public_html="public_html",,site=None):
"""Run,a,web,server,that,provides,Buildbot,status.
@type,,http_port:,int,or,L{twisted.application.strports},string
@param,http_port:,a,strports,specification,describing,which,port,the
buildbot,should,use,for,its,web,server,,with,the
Waterfall,display,as,the,root,page.,For,backwards
compatibility,this,can,also,be,an,int.,Use
'tcp:8000',to,listen,on,that,port,,or
'tcp:12345:interface=127.0.0.1',if,you,only,want
local,processes,to,connect,to,it,(perhaps,because
you,are,using,an,HTTP,reverse,proxy,to,make,the
buildbot,available,to,the,outside,world,,and,do,not
want,to,make,the,raw,port,visible).
@type,,distrib_port:,int,or,L{twisted.application.strports},string
@param,distrib_port:,Use,this,if,you,want,to,publish,the,Waterfall
page,using,web.distrib,instead.,The,most,common
case,is,to,provide,a,string,that,is,an,absolute
pathname,to,the,unix,socket,on,which,the
publisher,should,listen
(C{os.path.expanduser(~/.twistd-web-pb)},will
match,the,default,settings,of,a,standard
twisted.web,'personal,web,server').,Another
possibility,is,to,pass,an,integer,,which,means
the,publisher,should,listen,on,a,TCP,socket,
allowing,the,web,server,to,be,on,a,different
machine,entirely.,Both,forms,are,provided,for
backwards,compatibility,;,the,preferred,form,is,a
strports,specification,like
'unix:/home/buildbot/.twistd-web-pb'.,Providing
a,non-absolute,pathname,will,probably,confuse
the,strports,parser.
@param,allowForce:,boolean,,if,True,then,the,webserver,will,allow
visitors,to,trigger,and,cancel,builds
@param,public_html:,the,path,to,the,public_html,directory,for,this,display,
either,absolute,or,relative,to,the,basedir.,,The,default
is,'public_html',,which,selects,BASEDIR/public_html.
@type,site:,None,or,L{twisted.web.server.Site}
@param,site:,Use,this,if,you,want,to,define,your,own,object,instead,of
using,the,default.`
"""
service.MultiService.__init__(self)
if,type(http_port),is,int:
http_port,=,"tcp:%d",%,http_port
self.http_port,=,http_port
if,distrib_port,is,not,None:
if,type(distrib_port),is,int:
distrib_port,=,"tcp:%d",%,distrib_port
if,distrib_port[0],in,"/~.":,#,pathnames
distrib_port,=,"unix:%s",%,distrib_port
self.distrib_port,=,distrib_port
self.allowForce,=,allowForce
self.public_html,=,public_html
#,If,we,were,given,a,site,object,,go,ahead,and,use,it.
if,site:
self.site,=,site
else:
#,this,will,be,replaced,once,we've,been,attached,to,a,parent,(and
#,thus,have,a,basedir,and,can,reference,BASEDIR)
root,=,static.Data("placeholder",,"text/plain")
self.site,=,server.Site(root)
self.childrenToBeAdded,=,{}
self.setupUsualPages()
#,the,following,items,are,accessed,by,HtmlResource,when,it,renders
#,each,page.
self.site.buildbot_service,=,self
self.header,=,HEADER
self.head_elements,=,HEAD_ELEMENTS[:]
self.body_attrs,=,BODY_ATTRS.copy()
self.footer,=,FOOTER
self.template_values,=,{}
#,keep,track,of,cached,connections,so,we,can,break,them,when,we,shut
#,down.,See,ticket,#102,for,more,details.
self.channels,=,weakref.WeakKeyDictionary()
if,self.http_port,is,not,None:
s,=,strports.service(self.http_port,,self.site)
s.setServiceParent(self)
if,self.distrib_port,is,not,None:
f,=,pb.PBServerFactory(distrib.ResourcePublisher(self.site))
s,=,strports.service(self.distrib_port,,f)
s.setServiceParent(self)
def,setupUsualPages(self):
#self.putChild("",,IndexOrWaterfallRedirection())
self.putChild("waterfall",,WaterfallStatusResource())
self.putChild("grid",,GridStatusResource())
self.putChild("builders",,BuildersResource()),#,has,builds/steps/logs
self.putChild("changes",,ChangesResource())
self.putChild("buildslaves",,BuildSlavesResource())
#self.putChild("schedulers",,SchedulersResource())
self.putChild("one_line_per_build",,OneLinePerBuild())
self.putChild("one_box_per_builder",,OneBoxPerBuilder())
self.putChild("horizontal_one_box_per_builder",,HorizontalOneBoxPerBuilder())
self.putChild("xmlrpc",,XMLRPCServer())
self.putChild("about",,AboutBuildbot())
def,__repr__(self):
if,self.http_port,is,None:
return,"<WebStatus,on,path,%s,at,%s>",%,(self.distrib_port,
hex(id(self)))
if,self.distrib_port,is,None:
return,"<WebStatus,on,port,%s,at,%s>",%,(self.http_port,
hex(id(self)))
return,("<WebStatus,on,port,%s,and,path,%s,at,%s>",%
(self.http_port,,self.distrib_port,,hex(id(self))))
def,setServiceParent(self,,parent):
service.MultiService.setServiceParent(self,,parent)
#,this,class,keeps,a,*separate*,link,to,the,buildmaster,,rather,than
#,just,using,self.parent,,so,that,when,we,are,"disowned",(and,thus
#,parent=None),,any,remaining,HTTP,clients,of,this,WebStatus,will,still
#,be,able,to,get,reasonable,results.
self.master,=,parent
self.setupSite()
def,setupSite(self):
#,this,is,responsible,for,creating,the,root,resource.,It,isn't,done
#,at,__init__,time,because,we,need,to,reference,the,parent's,basedir.
htmldir,=,os.path.abspath(os.path.join(self.master.basedir,,self.public_html))
if,os.path.isdir(htmldir):
log.msg("WebStatus,using,(%s)",%,htmldir)
else:
log.msg("WebStatus:,warning:,%s,is,missing.,Do,you,need,to,run"
",'buildbot,upgrade-master',on,this,buildmaster?",%,htmldir)
#,all,static,pages,will,get,a,404,until,upgrade-master,is,used,to
#,populate,this,directory.,Create,the,directory,,though,,since
#,otherwise,we,get,internal,server,errors,instead,of,404s.
os.mkdir(htmldir)
root,=,static.File(htmldir)
for,name,,child_resource,in,self.childrenToBeAdded.iteritems():
root.putChild(name,,child_resource)
status,=,self.getStatus()
root.putChild("rss",,Rss20StatusResource(status))
root.putChild("atom",,Atom10StatusResource(status))
self.site.resource,=,root
def,putChild(self,,name,,child_resource):
"""This,behaves,a,lot,like,root.putChild(),.,"""
self.childrenToBeAdded[name],=,child_resource
def,registerChannel(self,,channel):
self.channels[channel],=,1,#,weakrefs
def,stopService(self):
for,channel,in,self.channels:
try:
channel.transport.loseConnection()
except:
log.msg("WebStatus.stopService:,error,while,disconnecting"
",leftover,clients")
log.err()
return,service.MultiService.stopService(self)
def,getStatus(self):
return,self.master.getStatus()
def,getControl(self):
if,self.allowForce:
return,IControl(self.master)
return,None
def,getChangeSvc(self):
return,self.master.change_svc
def,getPortnum(self):
#,this,is,for,the,benefit,of,unit,tests
s,=,list(self)[0]
return,s._port.getHost().port
#,resources,can,get,access,to,the,IStatus,by,calling
#,request.site.buildbot_service.getStatus()
#,this,is,the,compatibility,class,for,the,old,waterfall.,It,is,exactly,like,a
#,regular,WebStatus,except,that,the,root,resource,(e.g.,http://buildbot.net/)
#,always,redirects,to,a,WaterfallStatusResource,,and,the,old,arguments,are
#,mapped,into,the,new,resource-tree,approach.,In,the,normal,WebStatus,,the
#,root,resource,either,redirects,the,browser,to,/waterfall,or,serves
#,PUBLIC_HTML/index.html,,and,favicon/robots.txt,are,provided,by
#,having,the,admin,write,actual,files,into,PUBLIC_HTML/,.
#,note:,we,don't,use,a,util.Redirect,here,because,HTTP,requires,that,the
#,Location:,header,provide,an,absolute,URI,,and,it's,non-trivial,to,figure
#,out,our,absolute,URI,from,here.
class,Waterfall(WebStatus):
if,hasattr(sys,,"frozen"):
#,all,'data',files,are,in,the,directory,of,our,executable
here,=,os.path.dirname(sys.executable)
buildbot_icon,=,os.path.abspath(os.path.join(here,,"buildbot.png"))
buildbot_css,=,os.path.abspath(os.path.join(here,,"classic.css"))
else:
#,running,from,source
#,the,icon,is,sibpath(__file__,,"../buildbot.png"),.,This,is,for
#,portability.
up,=,os.path.dirname
buildbot_icon,=,os.path.abspath(os.path.join(up(up(up(__file__))),
"buildbot.png"))
buildbot_css,=,os.path.abspath(os.path.join(up(__file__),
"classic.css"))
compare_attrs,=,["http_port",,"distrib_port",,"allowForce",
"categories",,"css",,"favicon",,"robots_txt"]
def,__init__(self,,http_port=None,,distrib_port=None,,allowForce=True,
categories=None,,css=buildbot_css,,favicon=buildbot_icon,
robots_txt=None):
import,warnings
m,=,("buildbot.status.html.Waterfall,is,deprecated,as,of,0.7.6,"
"and,will,be,removed,from,a,future,release.,"
"Please,use,html.WebStatus,instead.")
warnings.warn(m,,DeprecationWarning)
WebStatus.__init__(self,,http_port,,distrib_port,,allowForce)
self.css,=,css
if,css:
if,os.path.exists(os.path.join("public_html",,"buildbot.css")):
#,they've,upgraded,,so,defer,to,that,copy,instead
pass
else:
data,=,open(css,,"rb").read()
self.putChild("buildbot.css",,static.Data(data,,"text/plain"))
self.favicon,=,favicon
self.robots_txt,=,robots_txt
if,favicon:
data,=,open(favicon,,"rb").read()
self.putChild("favicon.ico",,static.Data(data,,"image/x-icon"))
if,robots_txt:
data,=,open(robots_txt,,"rb").read()
self.putChild("robots.txt",,static.Data(data,,"text/plain"))
self.putChild("",,WaterfallStatusResource(categories))
#,-*-,test-case-name:,buildbot.test.test_web,-*-
#,This,Source,Code,Form,is,subject,to,the,terms,of,the,Mozilla,Public
#,License,,v.,2.0.,If,a,copy,of,the,MPL,was,not,distributed,with,this
#,file,,You,can,obtain,one,at,http://mozilla.org/MPL/2.0/.
from,zope.interface,import,implements
from,twisted.python,import,log,,components
from,twisted.web,import,html
import,urllib
import,time
import,operator
import,os
from,buildbot,import,interfaces,,util
from,buildbot,import,version
from,buildbot.status,import,builder
from,buildbot.status.web.base,import,Box,,HtmlResource,,IBox,,ICurrentBox,,\
ITopBox,,td,,build_get_class,,path_to_build,,path_to_step,,map_branches
class,CurrentBox(components.Adapter):
#,this,provides,the,"current,activity",box,,just,above,the,builder,name
implements(ICurrentBox)
def,formatETA(self,,prefix,,eta):
if,eta,is,None:
return,[]
if,eta,<,60:
return,["<,1,min"]
eta_parts,=,["~"]
eta_secs,=,eta
if,eta_secs,>,3600:
eta_parts.append("%d,hrs",%,(eta_secs,/,3600))
eta_secs,%=,3600
if,eta_secs,>,60:
eta_parts.append("%d,mins",%,(eta_secs,/,60))
eta_secs,%=,60
abstime,=,time.strftime("%H:%M",,time.localtime(util.now()+eta))
return,[prefix,,",".join(eta_parts),,"at,%s",%,abstime]
def,getBox(self,,status):
#,getState(),returns,offline,,idle,,or,building
state,,builds,=,self.original.getState()
#,look,for,upcoming,builds.,We,say,the,state,is,"waiting",if,the
#,builder,is,otherwise,idle,and,there,is,a,scheduler,which,tells,us,a
#,build,will,be,performed,some,time,in,the,near,future.,TODO:,this
#,functionality,used,to,be,in,BuilderStatus..,maybe,this,code,should
#,be,merged,back,into,it.
upcoming,=,[]
builderName,=,self.original.getName()
for,s,in,status.getSchedulers():
if,builderName,in,s.listBuilderNames():
upcoming.extend(s.getPendingBuildTimes())
if,state,==,"idle",and,upcoming:
state,=,"waiting"
if,state,==,"building":
text,=,["building"]
if,builds:
for,b,in,builds:
eta,=,b.getETA()
text.extend(self.formatETA("ETA,in",,eta))
elif,state,==,"offline":
text,=,["offline"]
elif,state,==,"idle":
text,=,["idle"]
elif,state,==,"waiting":
text,=,["waiting"]
else:
#,just,in,case,I,add,a,state,and,forget,to,update,this
text,=,[state]
#,TODO:,for,now,,this,pending/upcoming,stuff,is,in,the,"current
#,activity",box,,but,really,it,should,go,into,a,"next,activity",row
#,instead.,The,only,times,it,should,show,up,in,"current,activity",is
#,when,the,builder,is,otherwise,idle.
#,are,any,builds,pending?,(waiting,for,a,slave,to,be,free)
pbs,=,self.original.getPendingBuilds()
if,pbs:
text.append("%d,pending",%,len(pbs))
for,t,in,upcoming:
eta,=,t,-,util.now()
text.extend(self.formatETA("next,in",,eta))
return,Box(text,,class_="Activity,",+,state)
components.registerAdapter(CurrentBox,,builder.BuilderStatus,,ICurrentBox)
class,BuildTopBox(components.Adapter):
#,this,provides,a,per-builder,box,at,the,very,top,of,the,display,
#,showing,the,results,of,the,most,recent,build
implements(IBox)
def,getBox(self,,req):
assert,interfaces.IBuilderStatus(self.original)
branches,=,[b,for,b,in,req.args.get("branch",,[]),if,b]
builder,=,self.original
builds,=,list(builder.generateFinishedBuilds(map_branches(branches),
num_builds=1))
if,not,builds:
return,Box(["none"],,class_="LastBuild")
b,=,builds[0]
name,=,b.getBuilder().getName()
number,=,b.getNumber()
url,=,path_to_build(req,,b)
text,=,b.getText()
tests_failed,=,b.getSummaryStatistic('tests-failed',,operator.add,,0)
if,tests_failed:,text.extend(["Failed,tests:,%d",%,tests_failed])
#,TODO:,maybe,add,logs?
#,TODO:,add,link,to,the,per-build,page,at,'url'
class_,=,build_get_class(b)
return,Box(text,,class_="LastBuild,%s",%,class_)
components.registerAdapter(BuildTopBox,,builder.BuilderStatus,,ITopBox)
class,BuildBox(components.Adapter):
#,this,provides,the,yellow,"starting,line",box,for,each,build
implements(IBox)
def,getBox(self,,req):
b,=,self.original
number,=,b.getNumber()
url,=,path_to_build(req,,b)
reason,=,b.getReason()
#,Update,the,buildbot,BuildStatus,so,that,it,displays,the,hg,revision,number,as,the,build,number
changedesc='(%d)',%,number
revision=b.getSourceStamp().revision
if,(len(b.changes)>0):
changedesc='%s,(%d)',%,(b.changes[0].revision,number)
if,(revision):
changedesc="%s,(%d)",%,(revision,number)
text,=,('<a,title="Reason:,%s",href="%s">Build,%s</a>'
%,(html.escape(reason),,url,,changedesc)),
class_,=,"start"
if,b.isFinished(),and,not,b.getSteps():
#,the,steps,have,been,pruned,,so,there,won't,be,any,indication
#,of,whether,it,succeeded,or,failed.
class_,=,build_get_class(b)
return,Box([text],,class_="BuildStep,",+,class_)
components.registerAdapter(BuildBox,,builder.BuildStatus,,IBox)
class,StepBox(components.Adapter):
implements(IBox)
def,getBox(self,,req):
urlbase,=,path_to_step(req,,self.original)
text,=,self.original.getText()
if,text,is,None:
log.msg("getText(),gave,None",,urlbase)
text,=,[]
text,=,text[:]
logs,=,self.original.getLogs()
for,num,in,range(len(logs)):
name,=,logs[num].getName()
if,logs[num].hasContents():
url,=,urlbase,+,"/logs/%s",%,urllib.quote(name)
text.append("<a,href=\"%s\">%s</a>",%,(url,,html.escape(name)))
else:
text.append(html.escape(name))
urls,=,self.original.getURLs()
ex_url_class,=,"BuildStep,external"
for,name,,target,in,urls.items():
text.append('[<a,href="%s",class="%s">%s</a>]',%
(target,,ex_url_class,,html.escape(name)))
class_,=,"BuildStep,",+,build_get_class(self.original)
return,Box(text,,class_=class_)
components.registerAdapter(StepBox,,builder.BuildStepStatus,,IBox)
class,EventBox(components.Adapter):
implements(IBox)
def,getBox(self,,req):
text,=,self.original.getText()
class_,=,"Event"
return,Box(text,,class_=class_)
components.registerAdapter(EventBox,,builder.Event,,IBox)
class,Spacer:
implements(interfaces.IStatusEvent)
def,__init__(self,,start,,finish):
self.started,=,start
self.finished,=,finish
def,getTimes(self):
return,(self.started,,self.finished)
def,getText(self):
return,[]
class,SpacerBox(components.Adapter):
implements(IBox)
def,getBox(self,,req):
#b,=,Box(["spacer"],,"white")
b,=,Box([])
b.spacer,=,True
return,b
components.registerAdapter(SpacerBox,,Spacer,,IBox)
def,insertGaps(g,,lastEventTime,,idleGap=2):
debug,=,False
e,=,g.next()
starts,,finishes,=,e.getTimes()
if,debug:,log.msg("E0",,starts,,finishes)
if,finishes,==,0:
finishes,=,starts
if,debug:,log.msg("E1,finishes=%s,,gap=%s,,lET=%s",%,\
(finishes,,idleGap,,lastEventTime))
if,finishes,is,not,None,and,finishes,+,idleGap,<,lastEventTime:
if,debug:,log.msg(",spacer0")
yield,Spacer(finishes,,lastEventTime)
followingEventStarts,=,starts
if,debug:,log.msg(",fES0",,starts)
yield,e
while,1:
e,=,g.next()
starts,,finishes,=,e.getTimes()
if,debug:,log.msg("E2",,starts,,finishes)
if,finishes,==,0:
finishes,=,starts
if,finishes,is,not,None,and,finishes,+,idleGap,<,followingEventStarts:
#,there,is,a,gap,between,the,end,of,this,event,and,the,beginning
#,of,the,next,one.,Insert,an,idle,event,so,the,waterfall,display
#,shows,a,gap,here.
if,debug:
log.msg(",finishes=%s,,gap=%s,,fES=%s",%,\
(finishes,,idleGap,,followingEventStarts))
yield,Spacer(finishes,,followingEventStarts)
yield,e
followingEventStarts,=,starts
if,debug:,log.msg(",fES1",,starts)
HELP,=,'''
<form,action="../waterfall",method="GET">
<h1>The,Waterfall,Display</h1>
<p>The,Waterfall,display,can,be,controlled,by,adding,query,arguments,to,the
URL.,For,example,,if,your,Waterfall,is,accessed,via,the,URL
<tt>http://buildbot.example.org:8080</tt>,,then,you,could,add,a
<tt>branch=</tt>,argument,(described,below),by,going,to
<tt>http://buildbot.example.org:8080?branch=beta4</tt>,instead.,Remember,that
query,arguments,are,separated,from,each,other,with,ampersands,,but,they,are
separated,from,the,main,URL,with,a,question,mark,,so,to,add,a
<tt>branch=</tt>,and,two,<tt>builder=</tt>,arguments,,you,would,use
<tt>http://buildbot.example.org:8080?branch=beta4&amp,;builder=unix&amp,;builder=macos</tt>.</p>
<h2>Limiting,the,Displayed,Interval</h2>
<p>The,<tt>last_time=</tt>,argument,is,a,unix,timestamp,(seconds,since,the
start,of,1970),that,will,be,used,as,an,upper,bound,on,the,interval,of,events
displayed:,nothing,will,be,shown,that,is,more,recent,than,the,given,time.
When,no,argument,is,provided,,all,events,up,to,and,including,the,most,recent
steps,are,included.</p>
<p>The,<tt>first_time=</tt>,argument,provides,the,lower,bound.,No,events,will
be,displayed,that,occurred,<b>before</b>,this,timestamp.,Instead,of,providing
<tt>first_time=</tt>,,you,can,provide,<tt>show_time=</tt>:,in,this,case,
<tt>first_time</tt>,will,be,set,equal,to,<tt>last_time</tt>,minus
<tt>show_time</tt>.,<tt>show_time</tt>,overrides,<tt>first_time</tt>.</p>
<p>The,display,normally,shows,the,latest,200,events,that,occurred,in,the
given,interval,,where,each,timestamp,on,the,left,hand,edge,counts,as,a,single
event.,You,can,add,a,<tt>num_events=</tt>,argument,to,override,this,this.</p>
<h2>Hiding,non-Build,events</h2>
<p>By,passing,<tt>show_events=false</tt>,,you,can,remove,the,"buildslave
attached",,"buildslave,detached",,and,"builder,reconfigured",events,that
appear,in-between,the,actual,builds.</p>
%(show_events_input)s
<h2>Showing,only,Certain,Branches</h2>
<p>If,you,provide,one,or,more,<tt>branch=</tt>,arguments,,the,display,will,be
limited,to,builds,that,used,one,of,the,given,branches.,If,no,<tt>branch=</tt>
arguments,are,given,,builds,from,all,branches,will,be,displayed.</p>
Erase,the,text,from,these,"Show,Branch:",boxes,to,remove,that,branch,filter.
%(show_branches_input)s
<h2>Limiting,the,Builders,that,are,Displayed</h2>
<p>By,adding,one,or,more,<tt>builder=</tt>,arguments,,the,display,will,be
limited,to,showing,builds,that,ran,on,the,given,builders.,This,serves,to
limit,the,display,to,the,specific,named,columns.,If,no,<tt>builder=</tt>
arguments,are,provided,,all,Builders,will,be,displayed.</p>
<p>To,view,a,Waterfall,page,with,only,a,subset,of,Builders,displayed,,select
the,Builders,you,are,interested,in,here.</p>
%(show_builders_input)s
<h2>Auto-reloading,the,Page</h2>
<p>Adding,a,<tt>reload=</tt>,argument,will,cause,the,page,to,automatically
reload,itself,after,that,many,seconds.</p>
%(show_reload_input)s
<h2>Reload,Waterfall,Page</h2>
<input,type="submit",value="View,Waterfall",/>
</form>
'''
class,WaterfallHelp(HtmlResource):
title,=,"Waterfall,Help"
def,__init__(self,,categories=None):
HtmlResource.__init__(self)
self.categories,=,categories
def,body(self,,request):
data,=,''
status,=,self.getStatus(request)
showEvents_checked,=,'checked="checked"'
if,request.args.get("show_events",,["true"])[0].lower(),==,"true":
showEvents_checked,=,''
show_events_input,=,('<p>'
'<input,type="checkbox",name="show_events",'
'value="false",%s>'
'Hide,non-Build,events'
'</p>\n'
),%,showEvents_checked
branches,=,[b
for,b,in,request.args.get("branch",,[])
if,b]
branches.append('')
show_branches_input,=,'<table>\n'
for,b,in,branches:
show_branches_input,+=,('<tr>'
'<td>Show,Branch:,'
'<input,type="text",name="branch",'
'value="%s">'
'</td></tr>\n'
),%,(b,)
show_branches_input,+=,'</table>\n'
#,this,has,a,set,of,toggle-buttons,to,let,the,user,choose,the
#,builders
showBuilders,=,request.args.get("show",,[])
showBuilders.extend(request.args.get("builder",,[]))
allBuilders,=,status.getBuilderNames(categories=self.categories)
show_builders_input,=,'<table>\n'
for,bn,in,allBuilders:
checked,=,""
if,bn,in,showBuilders:
checked,=,'checked="checked"'
show_builders_input,+=,('<tr>'
'<td><input,type="checkbox"'
',name="builder",'
'value="%s",%s></td>,'
'<td>%s</td></tr>\n'
),%,(bn,,checked,,bn)
show_builders_input,+=,'</table>\n'
#,a,couple,of,radio-button,selectors,for,refresh,time,will,appear
#,just,after,that,text
show_reload_input,=,'<table>\n'
times,=,[("none",,"None"),
("60",,"60,seconds"),
("300",,"5,minutes"),
("600",,"10,minutes"),
]
current_reload_time,=,request.args.get("reload",,["none"])
if,current_reload_time:
current_reload_time,=,current_reload_time[0]
if,current_reload_time,not,in,[t[0],for,t,in,times]:
times.insert(0,,(current_reload_time,,current_reload_time),)
for,value,,name,in,times:
checked,=,""
if,value,==,current_reload_time:
checked,=,'checked="checked"'
show_reload_input,+=,('<tr>'
'<td><input,type="radio",name="reload",'
'value="%s",%s></td>,'
'<td>%s</td></tr>\n'
),%,(value,,checked,,name)
show_reload_input,+=,'</table>\n'
fields,=,{"show_events_input":,show_events_input,
"show_branches_input":,show_branches_input,
"show_builders_input":,show_builders_input,
"show_reload_input":,show_reload_input,
}
data,+=,HELP,%,fields
return,data
class,WaterfallStatusResource(HtmlResource):
"""This,builds,the,main,status,page,,with,the,waterfall,display,,and
all,child,pages."""
def,__init__(self,,categories=None):
HtmlResource.__init__(self)
self.categories,=,categories
self.putChild("help",,WaterfallHelp(categories))
def,getTitle(self,,request):
status,=,self.getStatus(request)
p,=,status.getProjectName()
if,p:
return,"BuildBot:,%s",%,p
else:
return,"BuildBot"
def,getChangemaster(self,,request):
#,TODO:,this,wants,to,go,away,,access,it,through,IStatus
return,request.site.buildbot_service.getChangeSvc()
def,get_reload_time(self,,request):
if,"reload",in,request.args:
try:
reload_time,=,int(request.args["reload"][0])
return,max(reload_time,,15)
except,ValueError:
pass
return,None
def,head(self,,request):
head,=,''
reload_time,=,self.get_reload_time(request)
if,reload_time,is,not,None:
head,+=,'<meta,http-equiv="refresh",content="%d">\n',%,reload_time
return,head
def,body(self,,request):
"This,method,builds,the,main,waterfall,display."
status,=,self.getStatus(request)
data,=,''
projectName,=,status.getProjectName()
projectURL,=,status.getProjectURL()
phase,=,request.args.get("phase",["2"])
phase,=,int(phase[0])
#,we,start,with,all,Builders,available,to,this,Waterfall:,this,is
#,limited,by,the,config-file,-time,categories=,argument,,and,defaults
#,to,all,defined,Builders.
allBuilderNames,=,status.getBuilderNames(categories=self.categories)
builders,=,[status.getBuilder(name),for,name,in,allBuilderNames]
#,but,if,the,URL,has,one,or,more,builder=,arguments,(or,the,old,show=
#,argument,,which,is,still,accepted,for,backwards,compatibility),,we
#,use,that,set,of,builders,instead.,We,still,don't,show,anything
#,outside,the,config-file,time,set,limited,by,categories=.
showBuilders,=,request.args.get("show",,[])
showBuilders.extend(request.args.get("builder",,[]))
if,showBuilders:
builders,=,[b,for,b,in,builders,if,b.name,in,showBuilders]
#,now,,if,the,URL,has,one,or,category=,arguments,,use,them,as,a
#,filter:,only,show,those,builders,which,belong,to,one,of,the,given
#,categories.
showCategories,=,request.args.get("category",,[])
if,showCategories:
builders,=,[b,for,b,in,builders,if,b.category,in,showCategories]
builderNames,=,[b.name,for,b,in,builders]
if,phase,==,-1:
return,self.body0(request,,builders)
(changeNames,,builderNames,,timestamps,,eventGrid,,sourceEvents),=,\
self.buildGrid(request,,builders)
if,phase,==,0:
return,self.phase0(request,,(changeNames,+,builderNames),
timestamps,,eventGrid)
#,start,the,table:,top-header,material
data,+=,'<table,border="0",cellspacing="0">\n'
if,projectName,and,projectURL:
#,TODO:,this,is,going,to,look,really,ugly
topleft,=,'<a,href="%s">%s</a><br,/>last,build',%,\
(projectURL,,projectName)
else:
topleft,=,"last,build"
data,+=,',<tr,class="LastBuild">\n'
data,+=,td(topleft,,align="right",,colspan=2,,class_="Project")
for,b,in,builders:
box,=,ITopBox(b).getBox(request)
data,+=,box.td(align="center")
data,+=,",</tr>\n"
data,+=,',<tr,class="Activity">\n'
data,+=,td('current,activity',,align='right',,colspan=2)
for,b,in,builders:
box,=,ICurrentBox(b).getBox(status)
data,+=,box.td(align="center")
data,+=,",</tr>\n"
data,+=,",<tr>\n"
TZ,=,time.tzname[time.localtime()[-1]]
data,+=,td("time,(%s)",%,TZ,,align="center",,class_="Time")
data,+=,td('<a,href="%s">changes</a>',%,request.childLink("../changes"),
align="center",,class_="Change")
for,name,in,builderNames:
safename,=,urllib.quote(name,,safe='')
data,+=,td('<a,href="%s">%s</a>',%
(request.childLink("../builders/%s",%,safename),,name),
align="center",,class_="Builder")
data,+=,",</tr>\n"
if,phase,==,1:
f,=,self.phase1
else:
f,=,self.phase2
data,+=,f(request,,changeNames,+,builderNames,,timestamps,,eventGrid,
sourceEvents)
data,+=,"</table>\n"
data,+=,'<hr,/><div,class="footer">\n'
def,with_args(req,,remove_args=[],,new_args=[],,new_path=None):
#,sigh,,nevow,makes,this,sort,of,manipulation,easier
newargs,=,req.args.copy()
for,argname,in,remove_args:
newargs[argname],=,[]
if,"branch",in,newargs:
newargs["branch"],=,[b,for,b,in,newargs["branch"],if,b]
for,k,v,in,new_args:
if,k,in,newargs:
newargs[k].append(v)
else:
newargs[k],=,[v]
newquery,=,"&".join(["%s=%s",%,(k,,v)
for,k,in,newargs
for,v,in,newargs[k]
])
if,new_path:
new_url,=,new_path
elif,req.prepath:
new_url,=,req.prepath[-1]
else:
new_url,=,''
if,newquery:
new_url,+=,"?",+,newquery
return,new_url
if,timestamps:
bottom,=,timestamps[-1]
nextpage,=,with_args(request,,["last_time"],
[("last_time",,str(int(bottom)))])
data,+=,'[<a,href="%s">next,page</a>]\n',%,nextpage
helpurl,=,self.path_to_root(request),+,"waterfall/help"
helppage,=,with_args(request,,new_path=helpurl)
data,+=,'[<a,href="%s">help</a>]\n',%,helppage
welcomeurl,=,self.path_to_root(request),+,"index.html"
data,+=,'[<a,href="%s">welcome</a>]\n',%,welcomeurl
if,self.get_reload_time(request),is,not,None:
no_reload_page,=,with_args(request,,remove_args=["reload"])
data,+=,'[<a,href="%s">Stop,Reloading</a>]\n',%,no_reload_page
data,+=,"<br,/>\n"
bburl,=,"http://buildbot.net/?bb-ver=%s",%,urllib.quote(version)
data,+=,'<a,href="%s">Buildbot-%s</a>,',%,(bburl,,version)
if,projectName:
data,+=,"working,for,the,"
if,projectURL:
data,+=,'<a,href="%s">%s</a>,project.',%,(projectURL,
projectName)
else:
data,+=,"%s,project.",%,projectName
data,+=,"<br,/>\n"
#,TODO:,push,this,to,the,right,edge,,if,possible
data,+=,("Page,built:,",+
time.strftime("%a,%d,%b,%Y,%H:%M:%S",
time.localtime(util.now()))
+,"\n")
data,+=,'</div>\n'
return,"%s,%s",%,(self.GetAnnounce(),,data)
def,GetAnnounce(self):
"""Creates,DIV,that,provides,visuals,on,tree,status.
"""
ANNOUNCEMENT_FILE,=,'public_html/announce.html'
return,self.GetStaticFileContent(ANNOUNCEMENT_FILE)
def,GetStaticFileContent(self,file):
if,os.path.exists(file):
announce,=,open(file,,'rb')
data,=,announce.read().strip()
announce.close()
return,data
else:
return,''
def,body0(self,,request,,builders):
#,build,the,waterfall,display
data,=,""
data,+=,"<h2>Basic,display</h2>\n"
data,+=,'<p>See,<a,href="%s">here</a>',%,request.childLink("../waterfall")
data,+=,",for,the,waterfall,display</p>\n"
data,+=,'<table,border="0",cellspacing="0">\n'
names,=,map(lambda,builder:,builder.name,,builders)
#,the,top,row,is,two,blank,spaces,,then,the,top-level,status,boxes
data,+=,",<tr>\n"
data,+=,td("",,colspan=2)
for,b,in,builders:
text,=,""
state,,builds,=,b.getState()
if,state,!=,"offline":
text,+=,"%s<br,/>\n",%,state,#b.getCurrentBig().text[0]
else:
text,+=,"OFFLINE<br,/>\n"
data,+=,td(text,,align="center")
#,the,next,row,has,the,column,headers:,time,,changes,,builder,names
data,+=,",<tr>\n"
data,+=,td("Time",,align="center")
data,+=,td("Changes",,align="center")
for,name,in,names:
data,+=,td('<a,href="%s">%s</a>',%
(request.childLink("../",+,urllib.quote(name)),,name),
align="center")
data,+=,",</tr>\n"
#,all,further,rows,involve,timestamps,,commit,events,,and,build,events
data,+=,",<tr>\n"
data,+=,td("04:00",,align="bottom")
data,+=,td("fred",,align="center")
for,name,in,names:
data,+=,td("stuff",,align="center")
data,+=,",</tr>\n"
data,+=,"</table>\n"
return,data
def,buildGrid(self,,request,,builders):
debug,=,False
#,TODO:,see,if,we,can,use,a,cached,copy
showEvents,=,False
if,request.args.get("show_events",,["true"])[0].lower(),==,"true":
showEvents,=,True
filterBranches,=,[b,for,b,in,request.args.get("branch",,[]),if,b]
filterBranches,=,map_branches(filterBranches)
maxTime,=,int(request.args.get("last_time",,[util.now()])[0])
if,"show_time",in,request.args:
minTime,=,maxTime,-,int(request.args["show_time"][0])
elif,"first_time",in,request.args:
minTime,=,int(request.args["first_time"][0])
else:
minTime,=,None
spanLength,=,10,,#,ten-second,chunks
maxPageLen,=,int(request.args.get("num_events",,[200])[0])
#,first,step,is,to,walk,backwards,in,time,,asking,each,column
#,(commit,,all,builders),if,they,have,any,events,there.,Build,up,the
#,array,of,events,,and,stop,when,we,have,a,reasonable,number.
commit_source,=,self.getChangemaster(request)
lastEventTime,=,util.now()
sources,=,[commit_source],+,builders
changeNames,=,["changes"]
builderNames,=,map(lambda,builder:,builder.getName(),,builders)
sourceNames,=,changeNames,+,builderNames
sourceEvents,=,[]
sourceGenerators,=,[]
def,get_event_from(g):
try:
while,True:
e,=,g.next()
#,e,might,be,builder.BuildStepStatus,
#,builder.BuildStatus,,builder.Event,
#,waterfall.Spacer(builder.Event),,or,changes.Change,.
#,The,showEvents=False,flag,means,we,should,hide
#,builder.Event,.
if,not,showEvents,and,isinstance(e,,builder.Event):
continue
break
event,=,interfaces.IStatusEvent(e)
if,debug:
log.msg("gen,%s,gave1,%s",%,(g,,event.getText()))
except,StopIteration:
event,=,None
return,event
for,s,in,sources:
gen,=,insertGaps(s.eventGenerator(filterBranches),,lastEventTime)
sourceGenerators.append(gen)
#,get,the,first,event
sourceEvents.append(get_event_from(gen))
eventGrid,=,[]
timestamps,=,[]
lastEventTime,=,0
for,e,in,sourceEvents:
if,e,and,e.getTimes()[0],>,lastEventTime:
lastEventTime,=,e.getTimes()[0]
if,lastEventTime,==,0:
lastEventTime,=,util.now()
spanStart,=,lastEventTime,-,spanLength
debugGather,=,0
while,1:
if,debugGather:,log.msg("checking,(%s,]",%,spanStart)
#,the,tableau,of,potential,events,is,in,sourceEvents[].,The
#,window,crawls,backwards,,and,we,examine,one,source,at,a,time.
#,If,the,source's,top-most,event,is,in,the,window,,is,it,pushed
#,onto,the,events[],array,and,the,tableau,is,refilled.,This
#,continues,until,the,tableau,event,is,not,in,the,window,(or,is
#,missing).
spanEvents,=,[],#,for,all,sources,,in,this,span.,row,of,eventGrid
firstTimestamp,=,None,#,timestamp,of,first,event,in,the,span
lastTimestamp,=,None,#,last,pre-span,event,,for,next,span
for,c,in,range(len(sourceGenerators)):
events,=,[],#,for,this,source,,in,this,span.,cell,of,eventGrid
event,=,sourceEvents[c]
while,event,and,spanStart,<,event.getTimes()[0]:
#,to,look,at,windows,that,don't,end,with,the,present,
#,condition,the,.append,on,event.time,<=,spanFinish
if,not,IBox(event,,None):
log.msg("BAD,EVENT",,event,,event.getText())
assert,0
if,debug:
log.msg("pushing",,event.getText(),,event)
events.append(event)
starts,,finishes,=,event.getTimes()
firstTimestamp,=,util.earlier(firstTimestamp,,starts)
event,=,get_event_from(sourceGenerators[c])
if,debug:
log.msg("finished,span")
if,event:
#,this,is,the,last,pre-span,event,for,this,source
lastTimestamp,=,util.later(lastTimestamp,
event.getTimes()[0])
if,debugGather:
log.msg(",got,%s,from,%s",%,(events,,sourceNames[c]))
sourceEvents[c],=,event,#,refill,the,tableau
spanEvents.append(events)
#,only,show,events,older,than,maxTime.,This,makes,it,possible,to
#,visit,a,page,that,shows,what,it,would,be,like,to,scroll,off,the
#,bottom,of,this,one.
if,firstTimestamp,is,not,None,and,firstTimestamp,<=,maxTime:
eventGrid.append(spanEvents)
timestamps.append(firstTimestamp)
if,lastTimestamp:
spanStart,=,lastTimestamp,-,spanLength
else:
#,no,more,events
break
if,minTime,is,not,None,and,lastTimestamp,<,minTime:
break
if,len(timestamps),>,maxPageLen:
break
#,now,loop
#,loop,is,finished.,now,we,have,eventGrid[],and,timestamps[]
if,debugGather:,log.msg("finished,loop")
assert(len(timestamps),==,len(eventGrid))
return,(changeNames,,builderNames,,timestamps,,eventGrid,,sourceEvents)
def,phase0(self,,request,,sourceNames,,timestamps,,eventGrid):
#,phase0,rendering
if,not,timestamps:
return,"no,events"
data,=,""
for,r,in,range(0,,len(timestamps)):
data,+=,"<p>\n"
data,+=,"[%s]<br,/>",%,timestamps[r]
row,=,eventGrid[r]
assert(len(row),==,len(sourceNames))
for,c,in,range(0,,len(row)):
if,row[c]:
data,+=,"<b>%s</b><br,/>\n",%,sourceNames[c]
for,e,in,row[c]:
log.msg("Event",,r,,c,,sourceNames[c],,e.getText())
lognames,=,[loog.getName(),for,loog,in,e.getLogs()]
data,+=,"%s:,%s:,%s<br,/>",%,(e.getText(),
e.getTimes()[0],
lognames)
else:
data,+=,"<b>%s</b>,[none]<br,/>\n",%,sourceNames[c]
return,data
def,phase1(self,,request,,sourceNames,,timestamps,,eventGrid,
sourceEvents):
#,phase1,rendering:,table,,but,boxes,do,not,overlap
data,=,""
if,not,timestamps:
return,data
lastDate,=,None
for,r,in,range(0,,len(timestamps)):
chunkstrip,=,eventGrid[r]
#,chunkstrip,is,a,horizontal,strip,of,event,blocks.,Each,block
#,is,a,vertical,list,of,events,,all,for,the,same,source.
assert(len(chunkstrip),==,len(sourceNames))
maxRows,=,reduce(lambda,x,y:,max(x,y),
map(lambda,x:,len(x),,chunkstrip))
for,i,in,range(maxRows):
data,+=,",<tr>\n",;
if,i,==,0:
stuff,=,[]
#,add,the,date,at,the,beginning,,and,each,time,it,changes
today,=,time.strftime("<b>%d,%b,%Y</b>",
time.localtime(timestamps[r]))
todayday,=,time.strftime("<b>%a</b>",
time.localtime(timestamps[r]))
if,today,!=,lastDate:
stuff.append(todayday)
stuff.append(today)
lastDate,=,today
stuff.append(
time.strftime("%H:%M:%S",
time.localtime(timestamps[r])))
data,+=,td(stuff,,valign="bottom",,align="center",
rowspan=maxRows,,class_="Time")
for,c,in,range(0,,len(chunkstrip)):
block,=,chunkstrip[c]
assert(block,!=,None),#,should,be,[],instead
#,bottom-justify
offset,=,maxRows,-,len(block)
if,i,<,offset:
data,+=,td("")
else:
e,=,block[i-offset]
box,=,IBox(e).getBox(request)
box.parms["show_idle"],=,1
data,+=,box.td(valign="top",,align="center")
data,+=,",</tr>\n"
return,data
def,phase2(self,,request,,sourceNames,,timestamps,,eventGrid,
sourceEvents):
data,=,""
if,not,timestamps:
return,data
#,first,pass:,figure,out,the,height,of,the,chunks,,populate,grid
grid,=,[]
for,i,in,range(1+len(sourceNames)):
grid.append([])
#,grid,is,a,list,of,columns,,one,for,the,timestamps,,and,one,per
#,event,source.,Each,column,is,exactly,the,same,height.,Each,element
#,of,the,list,is,a,single,<td>,box.
lastDate,=,time.strftime("<b>%d,%b,%Y</b>",
time.localtime(util.now()))
for,r,in,range(0,,len(timestamps)):
chunkstrip,=,eventGrid[r]
#,chunkstrip,is,a,horizontal,strip,of,event,blocks.,Each,block
#,is,a,vertical,list,of,events,,all,for,the,same,source.
assert(len(chunkstrip),==,len(sourceNames))
maxRows,=,reduce(lambda,x,y:,max(x,y),
map(lambda,x:,len(x),,chunkstrip))
for,i,in,range(maxRows):
if,i,!=,maxRows-1:
grid[0].append(None)
else:
#,timestamp,goes,at,the,bottom,of,the,chunk
stuff,=,[]
#,add,the,date,at,the,beginning,(if,it,is,not,the,same,as
#,today's,date),,and,each,time,it,changes
todayday,=,time.strftime("<b>%a</b>",
time.localtime(timestamps[r]))
today,=,time.strftime("<b>%d,%b,%Y</b>",
time.localtime(timestamps[r]))
if,today,!=,lastDate:
stuff.append(todayday)
stuff.append(today)
lastDate,=,today
stuff.append(
time.strftime("%H:%M:%S",
time.localtime(timestamps[r])))
grid[0].append(Box(text=stuff,,class_="Time",
valign="bottom",,align="center"))
#,at,this,point,the,timestamp,column,has,been,populated,with
#,maxRows,boxes,,most,None,but,the,last,one,has,the,time,string
for,c,in,range(0,,len(chunkstrip)):
block,=,chunkstrip[c]
assert(block,!=,None),#,should,be,[],instead
for,i,in,range(maxRows,-,len(block)):
#,fill,top,of,chunk,with,blank,space
grid[c+1].append(None)
for,i,in,range(len(block)):
#,so,the,events,are,bottom-justified
b,=,IBox(block[i]).getBox(request)
b.parms['valign'],=,"top"
b.parms['align'],=,"center"
grid[c+1].append(b)
#,now,all,the,other,columns,have,maxRows,new,boxes,too
#,populate,the,last,row,,if,empty
gridlen,=,len(grid[0])
for,i,in,range(len(grid)):
strip,=,grid[i]
assert(len(strip),==,gridlen)
if,strip[-1],==,None:
if,sourceEvents[i-1]:
filler,=,IBox(sourceEvents[i-1]).getBox(request)
else:
#,this,can,happen,if,you,delete,part,of,the,build,history
filler,=,Box(text=["?"],,align="center")
strip[-1],=,filler
strip[-1].parms['rowspan'],=,1
#,second,pass:,bubble,the,events,upwards,to,un-occupied,locations
#,Every,square,of,the,grid,that,has,a,None,in,it,needs,to,have
#,something,else,take,its,place.
noBubble,=,request.args.get("nobubble",['0'])
noBubble,=,int(noBubble[0])
if,not,noBubble:
for,col,in,range(len(grid)):
strip,=,grid[col]
if,col,==,1:,#,changes,are,handled,differently
for,i,in,range(2,,len(strip)+1):
#,only,merge,empty,boxes.,Don't,bubble,commit,boxes.
if,strip[-i],==,None:
next,=,strip[-i+1]
assert(next)
if,next:
#if,not,next.event:
if,next.spacer:
#,bubble,the,empty,box,up
strip[-i],=,next
strip[-i].parms['rowspan'],+=,1
strip[-i+1],=,None
else:
#,we,are,above,a,commit,box.,Leave,it
#,be,,and,turn,the,current,box,into,an
#,empty,one
strip[-i],=,Box([],,rowspan=1,
comment="commit,bubble")
strip[-i].spacer,=,True
else:
#,we,are,above,another,empty,box,,which
#,somehow,wasn't,already,converted.
#,Shouldn't,happen
pass
else:
for,i,in,range(2,,len(strip)+1):
#,strip[-i],will,go,from,next-to-last,back,to,first
if,strip[-i],==,None:
#,bubble,previous,item,up
assert(strip[-i+1],!=,None)
strip[-i],=,strip[-i+1]
strip[-i].parms['rowspan'],+=,1
strip[-i+1],=,None
else:
strip[-i].parms['rowspan'],=,1
#,third,pass:,render,the,HTML,table
for,i,in,range(gridlen):
data,+=,",<tr>\n",;
for,strip,in,grid:
b,=,strip[i]
if,b:
data,+=,b.td()
else:
if,noBubble:
data,+=,td([])
#,Nones,are,left,empty,,rowspan,should,make,it,all,fit
data,+=,",</tr>\n"
return,data
#,This,Source,Code,Form,is,subject,to,the,terms,of,the,Mozilla,Public
#,License,,v.,2.0.,If,a,copy,of,the,MPL,was,not,distributed,with,this
#,file,,You,can,obtain,one,at,http://mozilla.org/MPL/2.0/.
from,twisted.python,import,log
from,twisted.web,import,xmlrpc
from,buildbot.status.builder,import,Results
from,itertools,import,count
class,XMLRPCServer(xmlrpc.XMLRPC):
def,__init__(self):
xmlrpc.XMLRPC.__init__(self)
def,render(self,,req):
#,extract,the,IStatus,and,IControl,objects,for,later,use,,since,they
#,come,from,the,request,object.,They'll,be,the,same,each,time,,but
#,they,aren't,available,until,the,first,request,arrives.
self.status,=,req.site.buildbot_service.getStatus()
self.control,=,req.site.buildbot_service.getControl()
return,xmlrpc.XMLRPC.render(self,,req)
def,xmlrpc_getAllBuilders(self):
"""Return,a,list,of,all,builder,names
"""
log.msg("getAllBuilders")
return,self.status.getBuilderNames()
def,xmlrpc_getLastBuildResults(self,,builder_name):
"""Return,the,result,of,the,last,build,for,the,given,builder
"""
builder,=,self.status.getBuilder(builder_name)
lastbuild,=,builder.getBuild(-1)
return,Results[lastbuild.getResults()]
def,xmlrpc_isBuildSetActive(self,,scheduler_names):
"""Return,whether,the,build,is,currently,active.,Treat,builders,that
are,offline,as,not,building,,which,means,they,will,be,skipped.
"""
#log.msg("isBuildSetActive(),called,for,:,%s",%,(scheduler_names))
if,scheduler_names,==,'':
#,Get,a,list,of,builders
buildNames,=,self.status.getBuilderNames()
for,builder,in,buildNames:
state,=,self.status.getBuilder(builder).getState()[0]
#log.msg("isBuildSetActive():,[%s],state:,%s",%,(builder,,state))
#,If,any,builder,is,in,'building',state,then,we,are,active,so,return
#,Possible,states,are:
#,,,building,->,instantly,return,True,,don't,need,to,check,any,other,builders
#,,,idle,->,we,might,return,False,if,nobody,is,'building'
#,,,offline,->,treat,as,idle,,don't,hold,up,any,additional,build,requests
#,,,,,,,,,,,,,,,This,means,that,the,build,MAY,be,skipped,if,another,request
#,,,,,,,,,,,,,,,if,another,request,comes,in,before,it,comes,online
if,state,==,"building":
#log.msg("isBuildSetActive():,[%s],is,building,,return,True",%,builder)
return,True
#,We,found,NO,builders,in,a,'building',state.,The,means:
#,,,,,,,a),all,builders,are,in,an,idle,state
#,,,,OR,b),one,or,more,builders,are,'oflline',and,other,are,in,'idle',state
return,False
else:
#,Get,a,list,of,scheudulers
schedulers,=,self.status.getSchedulers()
for,scheduler,in,schedulers:
if,scheduler.name,in,scheduler_names:
#,Get,a,list,of,builders
buildNames,=,scheduler.listBuilderNames()
for,builder,in,buildNames:
state,=,self.status.getBuilder(builder).getState()[0]
#log.msg("isBuildSetActive():,[%s-%s],state:,%s",%,(scheduler.name,,builder,,state))
#,If,any,builder,is,in,'building',state,then,we,are,active,so,return
#,Possible,states,are:
#,,,building,->,instantly,return,True,,don't,need,to,check,any,other,builders
#,,,idle,->,we,might,return,False,if,nobody,is,'building'
#,,,offline,->,treat,as,idle,,don't,hold,up,any,additional,build,requests
#,,,,,,,,,,,,,,,This,means,that,the,build,MAY,be,skipped,if,another,request
#,,,,,,,,,,,,,,,if,another,request,comes,in,before,it,comes,online
if,state,==,"building":
#log.msg("isBuildSetActive():,[%s-%s],is,building,,return,True",%,(scheduler.name,,builder))
return,True
#,We,found,NO,builders,in,a,'building',state.,The,means:
#,,,,,,,a),all,builders,are,in,an,idle,state
#,,,,OR,b),one,or,more,builders,are,'oflline',and,other,are,in,'idle',state
#log.msg("isBuildSetActive():,False")
return,False
def,xmlrpc_stopSchedulers(self,,scheduler_names):
"""Stops,any,active,builders,in,the,specified,schedulers
"""
if,scheduler_names,==,'':
#,Get,a,list,of,builders
buildNames,=,self.status.getBuilderNames()
for,builder,in,buildNames:
state,=,self.status.getBuilder(builder).getState()[0]
#log.msg("isBuildSetActive():,[%s],state:,%s",%,(builder,,state))
#,If,any,builder,is,in,'building',state,then,we,are,active,so,return
#,Possible,states,are:
#,,,building,->,instantly,return,True,,don't,need,to,check,any,other,builders
#,,,idle,->,we,might,return,False,if,nobody,is,'building'
#,,,offline,->,treat,as,idle,,don't,hold,up,any,additional,build,requests
#,,,,,,,,,,,,,,,This,means,that,the,build,MAY,be,skipped,if,another,request
#,,,,,,,,,,,,,,,if,another,request,comes,in,before,it,comes,online
if,state,==,"building":
#,get,the,internal,BUILD,number:
currBuildNum,=,self.status.getBuilder(builder).getCurrentBuilds()[0].getNumber()
#,Get,all,of,the,processBuilder,objects,,these,actaully,control,the,build,and
#,are,not,just,objects,that,collect,status,,these,are,what,we,can,actually,stop
allProcBuilders,=,self.status.botmaster.getBuilders()
#,loop,through,ALL,of,the,builders,and,find,the,one,that,matches,the,status,builder,
#,that,we,have,found,to,be,actively,building
for,procBuilder,in,allProcBuilders:
if,procBuilder.name,==,builder:
#,get,the,actual,process.Build,and,stop,it
procBuilder.getBuild(currBuildNum).stopBuild("Stopping,build,by,user,request")
else:
#,Get,a,list,of,scheudulers
schedulers,=,self.status.getSchedulers()
for,scheduler,in,schedulers:
if,scheduler.name,in,scheduler_names:
#,Get,a,list,of,builders
buildNames,=,scheduler.listBuilderNames()
for,builder,in,buildNames:
state,=,self.status.getBuilder(builder).getState()[0]
#,If,any,builder,is,in,'building',state,then,we,are,going,to,stop,it
#,Possible,states,are:
#,,,building,->,instantly,return,True,,don't,need,to,check,any,other,builders
#,,,idle,->,we,might,return,False,if,nobody,is,'building'
#,,,offline,->,treat,as,idle,,don't,hold,up,any,additional,build,requests
#,,,,,,,,,,,,,,,This,means,that,the,build,MAY,be,skipped,if,another,request
#,,,,,,,,,,,,,,,if,another,request,comes,in,before,it,comes,online
if,state,==,"building":
#,get,the,internal,BUILD,number:
currBuildNum,=,self.status.getBuilder(builder).getCurrentBuilds()[0].getNumber()
#,Get,all,of,the,processBuilder,objects,,these,actaully,control,the,build,and
#,are,not,just,objects,that,collect,status,,these,are,what,we,can,actually,stop
allProcBuilders,=,self.status.botmaster.getBuilders()
#,loop,through,ALL,of,the,builders,and,find,the,one,that,matches,the,status,builder,
#,that,we,have,found,to,be,actively,building
for,procBuilder,in,allProcBuilders:
if,procBuilder.name,==,builder:
#,get,the,actual,process.Build,and,stop,it
procBuilder.getBuild(currBuildNum).stopBuild("Stopping,build,by,user,request")
def,xmlrpc_getLastBuilds(self,,builder_name,,num_builds):
"""Return,the,last,N,completed,builds,for,the,given,builder.
'builder_name',is,the,name,of,the,builder,to,query
'num_builds',is,the,number,of,builds,to,return
	Each,build,is,returned,in,the,same,form,as,xmlrpc_getAllBuildsInInterval
"""
log.msg("getLastBuilds:,%s,-,%d",%,(builder_name,,num_builds))
builder,=,self.status.getBuilder(builder_name)
all_builds,=,[]
for,build_number,in,range(1,,num_builds+1):
build,=,builder.getBuild(-build_number)
if,not,build:
break
if,not,build.isFinished():
continue
(build_start,,build_end),=,build.getTimes()
ss,=,build.getSourceStamp()
branch,=,ss.branch
if,branch,is,None:
branch,=,""
try:
revision,=,build.getSourceStamp().revision
except,KeyError:
revision,=,""
revision,=,str(revision)
answer,=,(builder_name,
build.getNumber(),
build_end,
branch,
revision,
Results[build.getResults()],
build.getText(),
)
all_builds.append((build_end,,answer))
#,now,we've,gotten,all,the,builds,we're,interested,in.,Sort,them,by
#,end,time.
all_builds.sort(lambda,a,b:,cmp(a[0],,b[0]))
#,and,remove,the,timestamps
all_builds,=,[t[1],for,t,in,all_builds]
log.msg("ready,to,go:,%s",%,(all_builds,))
return,all_builds
def,xmlrpc_getAllBuildsInInterval(self,,start,,stop):
"""Return,a,list,of,builds,that,have,completed,after,the,'start'
timestamp,and,before,the,'stop',timestamp.,This,looks,at,all
Builders.
The,timestamps,are,integers,,interpreted,as,standard,unix,timestamps
(seconds,since,epoch).
Each,Build,is,returned,as,a,tuple,in,the,form::
(buildername,,buildnumber,,build_end,,branchname,,revision,
results,,text)
The,buildnumber,is,an,integer.,'build_end',is,an,integer,(seconds
since,epoch),specifying,when,the,build,finished.
The,branchname,is,a,string,,which,may,be,an,empty,string,to,indicate
None,(i.e.,the,default,branch).,The,revision,is,a,string,whose
meaning,is,specific,to,the,VC,system,in,use,,and,comes,from,the
'got_revision',build,property.,The,results,are,expressed,as,a,string,
one,of,('success',,'warnings',,'failure',,'exception').,The,text,is,a
list,of,short,strings,that,ought,to,be,joined,by,spaces,and,include
slightly,more,data,about,the,results,of,the,build.
"""
#log.msg("start:,%s,%s,%s",%,(start,,type(start),,start.__class__))
log.msg("getAllBuildsInInterval:,%d,-,%d",%,(start,,stop))
all_builds,=,[]
for,builder_name,in,self.status.getBuilderNames():
builder,=,self.status.getBuilder(builder_name)
for,build_number,in,count(1):
build,=,builder.getBuild(-build_number)
if,not,build:
break
if,not,build.isFinished():
continue
(build_start,,build_end),=,build.getTimes()
#,in,reality,,builds,are,mostly,ordered,by,start,time.,For
#,the,purposes,of,this,method,,we,pretend,that,they,are
#,strictly,ordered,by,end,time,,so,that,we,can,stop,searching
#,when,we,start,seeing,builds,that,are,outside,the,window.
if,build_end,>,stop:
continue,#,keep,looking
if,build_end,<,start:
break,#,stop,looking
ss,=,build.getSourceStamp()
branch,=,ss.branch
if,branch,is,None:
branch,=,""
try:
revision,=,build.getProperty("got_revision")
except,KeyError:
revision,=,""
revision,=,str(revision)
answer,=,(builder_name,
build.getNumber(),
build_end,
branch,
revision,
Results[build.getResults()],
build.getText(),
)
all_builds.append((build_end,,answer))
#,we've,gotten,all,the,builds,that,we,care,about,from,this
#,particular,builder,,so,now,we,can,continue,on,the,next,builder
#,now,we've,gotten,all,the,builds,we're,interested,in.,Sort,them,by
#,end,time.
all_builds.sort(lambda,a,b:,cmp(a[0],,b[0]))
#,and,remove,the,timestamps
all_builds,=,[t[1],for,t,in,all_builds]
log.msg("ready,to,go:,%s",%,(all_builds,))
return,all_builds
def,xmlrpc_getBuild(self,,builder_name,,build_number):
"""Return,information,about,a,specific,build.
"""
builder,=,self.status.getBuilder(builder_name)
build,=,builder.getBuild(build_number)
info,=,{}
info['builder_name'],=,builder.getName()
info['url'],=,self.status.getURLForThing(build),or,''
info['reason'],=,build.getReason()
info['slavename'],=,build.getSlavename()
info['results'],=,build.getResults()
info['text'],=,build.getText()
#,Added,to,help,out,requests,for,build,-N
info['number'],=,build.number
ss,=,build.getSourceStamp()
branch,=,ss.branch
if,branch,is,None:
branch,=,""
info['branch'],=,str(branch)
try:
revision,=,str(build.getProperty("got_revision"))
except,KeyError:
revision,=,""
info['revision'],=,str(revision)
info['start'],,info['end'],=,build.getTimes()
info_steps,=,[]
for,s,in,build.getSteps():
stepinfo,=,{}
stepinfo['name'],=,s.getName()
stepinfo['start'],,stepinfo['end'],=,s.getTimes()
stepinfo['results'],=,s.getResults()
info_steps.append(stepinfo)
info['steps'],=,info_steps
info_logs,=,[]
for,l,in,build.getLogs():
loginfo,=,{}
loginfo['name'],=,l.getStep().getName(),+,"/",+,l.getName()
#loginfo['text'],=,l.getText()
loginfo['text'],=,"HUGE"
info_logs.append(loginfo)
info['logs'],=,info_logs
return,info
#,-*-,test-case-name:,buildbot.test.test_vc,-*-
#,This,Source,Code,Form,is,subject,to,the,terms,of,the,Mozilla,Public
#,License,,v.,2.0.,If,a,copy,of,the,MPL,was,not,distributed,with,this
#,file,,You,can,obtain,one,at,http://mozilla.org/MPL/2.0/.
from,warnings,import,warn
from,email.Utils,import,formatdate
from,twisted.python,import,log
from,buildbot.process.buildstep,import,LoggingBuildStep,,LoggedRemoteCommand
from,buildbot.interfaces,import,BuildSlaveTooOldError
from,buildbot.status.builder,import,SKIPPED
class,Source(LoggingBuildStep):
"""This,is,a,base,class,to,generate,a,source,tree,in,the,buildslave.
Each,version,control,system,has,a,specialized,subclass,,and,is,expected
to,override,__init__,and,implement,computeSourceRevision(),and
startVC().,The,class,as,a,whole,builds,up,the,self.args,dictionary,,then
starts,a,LoggedRemoteCommand,with,those,arguments.
"""
#,if,the,checkout,fails,,there's,no,point,in,doing,anything,else
haltOnFailure,=,True
flunkOnFailure,=,True
notReally,=,False
branch,=,None,#,the,default,branch,,should,be,set,in,__init__
def,__init__(self,,workdir=None,,mode='update',,alwaysUseLatest=False,
timeout=20*60,,retry=None,,**kwargs):
"""
@type,,workdir:,string
@param,workdir:,local,directory,(relative,to,the,Builder's,root)
where,the,tree,should,be,placed
@type,,mode:,string
@param,mode:,the,kind,of,VC,operation,that,is,desired:
-,'update':,specifies,that,the,checkout/update,should,be
performed,directly,into,the,workdir.,Each,build,is,performed
in,the,same,directory,,allowing,for,incremental,builds.,This
minimizes,disk,space,,bandwidth,,and,CPU,time.,However,,it
may,encounter,problems,if,the,build,process,does,not,handle
dependencies,properly,(if,you,must,sometimes,do,a,'clean
build',to,make,sure,everything,gets,compiled),,or,if,source
files,are,deleted,but,generated,files,can,influence,test
behavior,(e.g.,python's,.pyc,files),,or,when,source
directories,are,deleted,but,generated,files,prevent,CVS,from
removing,them.
-,'copy':,specifies,that,the,source-controlled,workspace
should,be,maintained,in,a,separate,directory,(called,the
'copydir'),,using,checkout,or,update,as,necessary.,For,each
build,,a,new,workdir,is,created,with,a,copy,of,the,source
tree,(rm,-rf,workdir,;,cp,-R,-P,-p,copydir,workdir).,This
doubles,the,disk,space,required,,but,keeps,the,bandwidth,low
(update,instead,of,a,full,checkout).,A,full,'clean',build
is,performed,each,time.,,This,avoids,any,generated-file
build,problems,,but,is,still,occasionally,vulnerable,to
problems,such,as,a,CVS,repository,being,manually,rearranged
(causing,CVS,errors,on,update),which,are,not,an,issue,with
a,full,checkout.
-,'clobber':,specifies,that,the,working,directory,should,be
deleted,each,time,,necessitating,a,full,checkout,for,each
build.,This,insures,a,clean,build,off,a,complete,checkout,
avoiding,any,of,the,problems,described,above,,but,is
bandwidth,intensive,,as,the,whole,source,tree,must,be
pulled,down,for,each,build.
-,'export':,is,like,'clobber',,except,that,e.g.,the,'cvs
export',command,is,used,to,create,the,working,directory.
This,command,removes,all,VC,metadata,files,(the
CVS/.svn/{arch},directories),from,the,tree,,which,is
sometimes,useful,for,creating,source,tarballs,(to,avoid
including,the,metadata,in,the,tar,file).,Not,all,VC,systems
support,export.
@type,,alwaysUseLatest:,boolean
@param,alwaysUseLatest:,whether,to,always,update,to,the,most
recent,available,sources,for,this,build.
Normally,the,Source,step,asks,its,Build,for,a,list,of,all
Changes,that,are,supposed,to,go,into,the,build,,then,computes,a
'source,stamp',(revision,number,or,timestamp),that,will,cause
exactly,that,set,of,changes,to,be,present,in,the,checked,out
tree.,This,is,turned,into,,e.g.,,'cvs,update,-D,timestamp',,or
'svn,update,-r,revnum'.,If,alwaysUseLatest=True,,bypass,this
computation,and,always,update,to,the,latest,available,sources
for,each,build.
The,source,stamp,helps,avoid,a,race,condition,in,which,someone
commits,a,change,after,the,master,has,decided,to,start,a,build
but,before,the,slave,finishes,checking,out,the,sources.,At,best
this,results,in,a,build,which,contains,more,changes,than,the
buildmaster,thinks,it,has,(possibly,resulting,in,the,wrong
person,taking,the,blame,for,any,problems,that,result),,at,worst
is,can,result,in,an,incoherent,set,of,sources,(splitting,a
non-atomic,commit),which,may,not,build,at,all.
@type,,retry:,tuple,of,ints,(delay,,repeats),(or,None)
@param,retry:,if,provided,,VC,update,failures,are,re-attempted,up
to,REPEATS,times,,with,DELAY,seconds,between,each
attempt.,Some,users,have,slaves,with,poor,connectivity
to,their,VC,repository,,and,they,say,that,up,to,80%,of
their,build,failures,are,due,to,transient,network
failures,that,could,be,handled,by,simply,retrying,a
couple,times.
"""
LoggingBuildStep.__init__(self,,**kwargs)
self.addFactoryArguments(workdir=workdir,
mode=mode,
alwaysUseLatest=alwaysUseLatest,
timeout=timeout,
retry=retry,
)
assert,mode,in,("update",,"copy",,"clobber",,"export")
if,retry:
delay,,repeats,=,retry
assert,isinstance(repeats,,int)
assert,repeats,>,0
self.args,=,{'mode':,mode,
'workdir':,workdir,
'timeout':,timeout,
'retry':,retry,
'patch':,None,,#,set,during,.start
}
self.alwaysUseLatest,=,alwaysUseLatest
#,Compute,defaults,for,descriptions:
description,=,["updating"]
descriptionDone,=,["update"]
if,mode,==,"clobber":
description,=,["checkout"]
#,because,checkingouting,takes,too,much,space
descriptionDone,=,["checkout"]
elif,mode,==,"export":
description,=,["exporting"]
descriptionDone,=,["export"]
self.description,=,description
self.descriptionDone,=,descriptionDone
def,setDefaultWorkdir(self,,workdir):
self.args['workdir'],=,self.args['workdir'],or,workdir
def,describe(self,,done=False):
if,done:
return,self.descriptionDone
return,self.description
def,computeSourceRevision(self,,changes):
"""Each,subclass,must,implement,this,method,to,do,something,more
precise,than,-rHEAD,every,time.,For,version,control,systems,that,use
repository-wide,change,numbers,(SVN,,P4),,this,can,simply,take,the
maximum,such,number,from,all,the,changes,involved,in,this,build.,For
systems,that,do,not,(CVS),,it,needs,to,create,a,timestamp,based,upon
the,latest,Change,,the,Build's,treeStableTimer,,and,an,optional
self.checkoutDelay,value."""
return,None
def,start(self):
if,self.notReally:
log.msg("faking,%s,checkout/update",%,self.name)
self.step_status.setText(["fake",,self.name,,"successful"])
self.addCompleteLog("log",
"Faked,%s,checkout/update,'successful'\n",\
%,self.name)
return,SKIPPED
#,what,source,stamp,would,this,build,like,to,use?
s,=,self.build.getSourceStamp()
#,if,branch,is,None,,then,use,the,Step's,"default",branch
branch,=,s.branch,or,self.branch
#,if,revision,is,None,,use,the,latest,sources,(-rHEAD)
revision,=,s.revision
if,not,revision,and,not,self.alwaysUseLatest:
revision,=,self.computeSourceRevision(s.changes)
#,if,patch,is,None,,then,do,not,patch,the,tree,after,checkout
#,'patch',is,None,or,a,tuple,of,(patchlevel,,diff)
patch,=,s.patch
if,patch:
self.addCompleteLog("patch",,patch[1])
self.startVC(branch,,revision,,patch)
def,commandComplete(self,,cmd):
if,cmd.updates.has_key("got_revision"):
got_revision,=,cmd.updates["got_revision"][-1]
if,got_revision,is,not,None:
self.setProperty("got_revision",,str(got_revision),,"Source")
class,CVS(Source):
"""I,do,CVS,checkout/update,operations.
Note:,if,you,are,doing,anonymous/pserver,CVS,operations,,you,will,need
to,manually,do,a,'cvs,login',on,each,buildslave,before,the,slave,has,any
hope,of,success.,XXX:,fix,then,,take,a,cvs,password,as,an,argument,and
figure,out,how,to,do,a,'cvs,login',on,each,build
"""
name,=,"cvs"
#progressMetrics,=,('output',)
#
#,additional,things,to,track:,update,gives,one,stderr,line,per,directory
#,(starting,with,'cvs,server:,Updating,'),(and,is,fairly,stable,if,files
#,is,empty),,export,gives,one,line,per,directory,(starting,with,'cvs
#,export:,Updating,'),and,another,line,per,file,(starting,with,U).,Would
#,be,nice,to,track,these,,requires,grepping,LogFile,data,for,lines,
#,parsing,each,line.,Might,be,handy,to,have,a,hook,in,LogFile,that,gets
#,called,with,each,complete,line.
def,__init__(self,,cvsroot,,cvsmodule,
global_options=[],,branch=None,,checkoutDelay=None,
login=None,
**kwargs):
"""
@type,,cvsroot:,string
@param,cvsroot:,CVS,Repository,from,which,the,source,tree,should
be,obtained.,'/home/warner/Repository',for,local
or,NFS-reachable,repositories,
':pserver:anon@foo.com:/cvs',for,anonymous,CVS,
'user@host.com:/cvs',for,non-anonymous,CVS,or
CVS,over,ssh.,Lots,of,possibilities,,check,the
CVS,documentation,for,more.
@type,,cvsmodule:,string
@param,cvsmodule:,subdirectory,of,CVS,repository,that,should,be
retrieved
@type,,login:,string,or,None
@param,login:,if,not,None,,a,string,which,will,be,provided,as,a
password,to,the,'cvs,login',command,,used,when,a
:pserver:,method,is,used,to,access,the,repository.
This,login,is,only,needed,once,,but,must,be,run
each,time,(just,before,the,CVS,operation),because
there,is,no,way,for,the,buildslave,to,tell,whether
it,was,previously,performed,or,not.
@type,,branch:,string
@param,branch:,the,default,branch,name,,will,be,used,in,a,'-r'
argument,to,specify,which,branch,of,the,source,tree
should,be,used,for,this,checkout.,Defaults,to,None,
which,means,to,use,'HEAD'.
@type,,checkoutDelay:,int,or,None
@param,checkoutDelay:,if,not,None,,the,number,of,seconds,to,put
between,the,last,known,Change,and,the
timestamp,given,to,the,-D,argument.,This
defaults,to,exactly,half,of,the,parent
Build's,.treeStableTimer,,but,it,could,be
set,to,something,else,if,your,CVS,change
notification,has,particularly,weird
latency,characteristics.
@type,,global_options:,list,of,strings
@param,global_options:,these,arguments,are,inserted,in,the,cvs
command,line,,before,the
'checkout'/'update',command,word.,See
'cvs,--help-options',for,a,list,of,what
may,be,accepted,here.,,['-r'],will,make
the,checked,out,files,read,only.,['-r',
'-R'],will,also,assume,the,repository,is
read-only,(I,assume,this,means,it,won't
use,locks,to,insure,atomic,access,to,the
,v,files)."""
self.checkoutDelay,=,checkoutDelay
self.branch,=,branch
Source.__init__(self,,**kwargs)
self.addFactoryArguments(cvsroot=cvsroot,
cvsmodule=cvsmodule,
global_options=global_options,
branch=branch,
checkoutDelay=checkoutDelay,
login=login,
)
self.args.update({'cvsroot':,cvsroot,
'cvsmodule':,cvsmodule,
'global_options':,global_options,
'login':,login,
})
def,computeSourceRevision(self,,changes):
if,not,changes:
return,None
lastChange,=,max([c.when,for,c,in,changes])
if,self.checkoutDelay,is,not,None:
when,=,lastChange,+,self.checkoutDelay
else:
lastSubmit,=,max([r.submittedAt,for,r,in,self.build.requests])
when,=,(lastChange,+,lastSubmit),/,2
return,formatdate(when)
def,startVC(self,,branch,,revision,,patch):
if,self.slaveVersionIsOlderThan("cvs",,"1.39"):
#,the,slave,doesn't,know,to,avoid,re-using,the,same,sourcedir
#,when,the,branch,changes.,We,have,no,way,of,knowing,which,branch
#,the,last,build,used,,so,if,we're,using,a,non-default,branch,and
#,either,'update',or,'copy',modes,,it,is,safer,to,refuse,to
#,build,,and,tell,the,user,they,need,to,upgrade,the,buildslave.
if,(branch,!=,self.branch
and,self.args['mode'],in,("update",,"copy")):
m,=,("This,buildslave,(%s),does,not,know,about,multiple,"
"branches,,and,using,mode=%s,would,probably,build,the,"
"wrong,tree.,"
"Refusing,to,build.,Please,upgrade,the,buildslave,to,"
"buildbot-0.7.0,or,newer.",%,(self.build.slavename,
self.args['mode']))
log.msg(m)
raise,BuildSlaveTooOldError(m)
if,branch,is,None:
branch,=,"HEAD"
self.args['branch'],=,branch
self.args['revision'],=,revision
self.args['patch'],=,patch
if,self.args['branch'],==,"HEAD",and,self.args['revision']:
#,special,case.,'cvs,update,-r,HEAD,-D,today',gives,no,files
#,TODO:,figure,out,why,,see,if,it,applies,to,-r,BRANCH
self.args['branch'],=,None
#,deal,with,old,slaves
warnings,=,[]
slavever,=,self.slaveVersion("cvs",,"old")
if,slavever,==,"old":
#,0.5.0
if,self.args['mode'],==,"export":
self.args['export'],=,1
elif,self.args['mode'],==,"clobber":
self.args['clobber'],=,1
elif,self.args['mode'],==,"copy":
self.args['copydir'],=,"source"
self.args['tag'],=,self.args['branch']
assert,not,self.args['patch'],#,0.5.0,slave,can't,do,patch
cmd,=,LoggedRemoteCommand("cvs",,self.args)
self.startCommand(cmd,,warnings)
class,SVN(Source):
"""I,perform,Subversion,checkout/update,operations."""
name,=,'svn'
def,__init__(self,,svnurl=None,,baseURL=None,,defaultBranch=None,
directory=None,,username=None,,password=None,,**kwargs):
"""
@type,,svnurl:,string
@param,svnurl:,the,URL,which,points,to,the,Subversion,server,
combining,the,access,method,(HTTP,,ssh,,local,file),
the,repository,host/port,,the,repository,path,,the
sub-tree,within,the,repository,,and,the,branch,to
check,out.,Using,C{svnurl},does,not,enable,builds,of
alternate,branches:,use,C{baseURL},to,enable,this.
Use,exactly,one,of,C{svnurl},and,C{baseURL}.
@param,baseURL:,if,branches,are,enabled,,this,is,the,base,URL,to
which,a,branch,name,will,be,appended.,It,should
probably,end,in,a,slash.,Use,exactly,one,of
C{svnurl},and,C{baseURL}.
@param,defaultBranch:,if,branches,are,enabled,,this,is,the,branch
to,use,if,the,Build,does,not,specify,one
explicitly.,It,will,simply,be,appended
to,C{baseURL},and,the,result,handed,to
the,SVN,command.
@param,username:,username,to,pass,to,svn's,--username
@param,password:,username,to,pass,to,svn's,--password
"""
if,not,kwargs.has_key('workdir'),and,directory,is,not,None:
#,deal,with,old,configs
warn("Please,use,workdir=,,not,directory=",,DeprecationWarning)
kwargs['workdir'],=,directory
self.svnurl,=,svnurl
self.baseURL,=,baseURL
self.branch,=,defaultBranch
self.username,=,username
self.password,=,password
Source.__init__(self,,**kwargs)
self.addFactoryArguments(svnurl=svnurl,
baseURL=baseURL,
defaultBranch=defaultBranch,
directory=directory,
username=username,
password=password,
)
if,not,svnurl,and,not,baseURL:
raise,ValueError("you,must,use,exactly,one,of,svnurl,and,baseURL")
def,computeSourceRevision(self,,changes):
if,not,changes,or,None,in,[c.revision,for,c,in,changes]:
return,None
lastChange,=,max([int(c.revision),for,c,in,changes])
return,lastChange
def,startVC(self,,branch,,revision,,patch):
#,handle,old,slaves
warnings,=,[]
slavever,=,self.slaveVersion("svn",,"old")
if,not,slavever:
m,=,"slave,does,not,have,the,'svn',command"
raise,BuildSlaveTooOldError(m)
if,self.slaveVersionIsOlderThan("svn",,"1.39"):
#,the,slave,doesn't,know,to,avoid,re-using,the,same,sourcedir
#,when,the,branch,changes.,We,have,no,way,of,knowing,which,branch
#,the,last,build,used,,so,if,we're,using,a,non-default,branch,and
#,either,'update',or,'copy',modes,,it,is,safer,to,refuse,to
#,build,,and,tell,the,user,they,need,to,upgrade,the,buildslave.
if,(branch,!=,self.branch
and,self.args['mode'],in,("update",,"copy")):
m,=,("This,buildslave,(%s),does,not,know,about,multiple,"
"branches,,and,using,mode=%s,would,probably,build,the,"
"wrong,tree.,"
"Refusing,to,build.,Please,upgrade,the,buildslave,to,"
"buildbot-0.7.0,or,newer.",%,(self.build.slavename,
self.args['mode']))
raise,BuildSlaveTooOldError(m)
if,slavever,==,"old":
#,0.5.0,compatibility
if,self.args['mode'],in,("clobber",,"copy"):
#,TODO:,use,some,shell,commands,to,make,up,for,the
#,deficiency,,by,blowing,away,the,old,directory,first,(thus
#,forcing,a,full,checkout)
warnings.append("WARNING:,this,slave,can,only,do,SVN,updates"
",,not,mode=%s\n",%,self.args['mode'])
log.msg("WARNING:,this,slave,only,does,mode=update")
if,self.args['mode'],==,"export":
raise,BuildSlaveTooOldError("old,slave,does,not,have,"
"mode=export")
self.args['directory'],=,self.args['workdir']
if,revision,is,not,None:
#,0.5.0,can,only,do,HEAD.,We,have,no,way,of,knowing,whether
#,the,requested,revision,is,HEAD,or,not,,and,for
#,slowly-changing,trees,this,will,probably,do,the,right
#,thing,,so,let,it,pass,with,a,warning
m,=,("WARNING:,old,slave,can,only,update,to,HEAD,,not,"
"revision=%s",%,revision)
log.msg(m)
warnings.append(m,+,"\n")
revision,=,"HEAD",#,interprets,this,key,differently
if,patch:
raise,BuildSlaveTooOldError("old,slave,can't,do,patch")
if,self.svnurl:
assert,not,branch,#,we,need,baseURL=,to,use,branches
self.args['svnurl'],=,self.svnurl
else:
self.args['svnurl'],=,self.baseURL,+,branch
self.args['revision'],=,revision
self.args['patch'],=,patch
if,self.username,is,not,None,or,self.password,is,not,None:
if,self.slaveVersionIsOlderThan("svn",,"2.8"):
m,=,("This,buildslave,(%s),does,not,support,svn,usernames,"
"and,passwords.,,"
"Refusing,to,build.,Please,upgrade,the,buildslave,to,"
"buildbot-0.7.10,or,newer.",%,(self.build.slavename,))
raise,BuildSlaveTooOldError(m)
if,self.username,is,not,None:,self.args['username'],=,self.username
if,self.password,is,not,None:,self.args['password'],=,self.password
revstuff,=,[]
if,branch,is,not,None,and,branch,!=,self.branch:
revstuff.append("[branch]")
if,revision,is,not,None:
revstuff.append("r%s",%,revision)
if,patch,is,not,None:
revstuff.append("[patch]")
self.description.extend(revstuff)
self.descriptionDone.extend(revstuff)
cmd,=,LoggedRemoteCommand("svn",,self.args)
self.startCommand(cmd,,warnings)
class,Darcs(Source):
"""Check,out,a,source,tree,from,a,Darcs,repository,at,'repourl'.
Darcs,has,no,concept,of,file,modes.,This,means,the,eXecute-bit,will,be
cleared,on,all,source,files.,As,a,result,,you,may,need,to,invoke
configuration,scripts,with,something,like:
C{s(step.Configure,,command=['/bin/sh',,'./configure'])}
"""
name,=,"darcs"
def,__init__(self,,repourl=None,,baseURL=None,,defaultBranch=None,
**kwargs):
"""
@type,,repourl:,string
@param,repourl:,the,URL,which,points,at,the,Darcs,repository.,This
is,used,as,the,default,branch.,Using,C{repourl},does
not,enable,builds,of,alternate,branches:,use
C{baseURL},to,enable,this.,Use,either,C{repourl},or
C{baseURL},,not,both.
@param,baseURL:,if,branches,are,enabled,,this,is,the,base,URL,to
which,a,branch,name,will,be,appended.,It,should
probably,end,in,a,slash.,Use,exactly,one,of
C{repourl},and,C{baseURL}.
@param,defaultBranch:,if,branches,are,enabled,,this,is,the,branch
to,use,if,the,Build,does,not,specify,one
explicitly.,It,will,simply,be,appended,to
C{baseURL},and,the,result,handed,to,the
'darcs,pull',command.
"""
self.repourl,=,repourl
self.baseURL,=,baseURL
self.branch,=,defaultBranch
Source.__init__(self,,**kwargs)
self.addFactoryArguments(repourl=repourl,
baseURL=baseURL,
defaultBranch=defaultBranch,
)
assert,self.args['mode'],!=,"export",,\
"Darcs,does,not,have,an,'export',mode"
if,(not,repourl,and,not,baseURL),or,(repourl,and,baseURL):
raise,ValueError("you,must,provide,exactly,one,of,repourl,and"
",baseURL")
def,startVC(self,,branch,,revision,,patch):
slavever,=,self.slaveVersion("darcs")
if,not,slavever:
m,=,"slave,is,too,old,,does,not,know,about,darcs"
raise,BuildSlaveTooOldError(m)
if,self.slaveVersionIsOlderThan("darcs",,"1.39"):
if,revision:
#,TODO:,revisit,this,once,we,implement,computeSourceRevision
m,=,"0.6.6,slaves,can't,handle,args['revision']"
raise,BuildSlaveTooOldError(m)
#,the,slave,doesn't,know,to,avoid,re-using,the,same,sourcedir
#,when,the,branch,changes.,We,have,no,way,of,knowing,which,branch
#,the,last,build,used,,so,if,we're,using,a,non-default,branch,and
#,either,'update',or,'copy',modes,,it,is,safer,to,refuse,to
#,build,,and,tell,the,user,they,need,to,upgrade,the,buildslave.
if,(branch,!=,self.branch
and,self.args['mode'],in,("update",,"copy")):
m,=,("This,buildslave,(%s),does,not,know,about,multiple,"
"branches,,and,using,mode=%s,would,probably,build,the,"
"wrong,tree.,"
"Refusing,to,build.,Please,upgrade,the,buildslave,to,"
"buildbot-0.7.0,or,newer.",%,(self.build.slavename,
self.args['mode']))
raise,BuildSlaveTooOldError(m)
if,self.repourl:
assert,not,branch,#,we,need,baseURL=,to,use,branches
self.args['repourl'],=,self.repourl
else:
self.args['repourl'],=,self.baseURL,+,branch
self.args['revision'],=,revision
self.args['patch'],=,patch
revstuff,=,[]
if,branch,is,not,None,and,branch,!=,self.branch:
revstuff.append("[branch]")
self.description.extend(revstuff)
self.descriptionDone.extend(revstuff)
cmd,=,LoggedRemoteCommand("darcs",,self.args)
self.startCommand(cmd)
class,Git(Source):
"""Check,out,a,source,tree,from,a,git,repository,'repourl'."""
name,=,"git"
def,__init__(self,,repourl,,branch="master",,**kwargs):
"""
@type,,repourl:,string
@param,repourl:,the,URL,which,points,at,the,git,repository
@type,,branch:,string
@param,branch:,The,branch,or,tag,to,check,out,by,default.,If
a,build,specifies,a,different,branch,,it,will
be,used,instead,of,this.
"""
Source.__init__(self,,**kwargs)
self.addFactoryArguments(repourl=repourl,,branch=branch)
self.args.update({'repourl':,repourl,
'branch':,branch})
def,computeSourceRevision(self,,changes):
if,not,changes:
return,None
return,changes[-1].revision
def,startVC(self,,branch,,revision,,patch):
if,branch,is,not,None:
self.args['branch'],=,branch
self.args['revision'],=,revision
self.args['patch'],=,patch
slavever,=,self.slaveVersion("git")
if,not,slavever:
raise,BuildSlaveTooOldError("slave,is,too,old,,does,not,know,"
"about,git")
cmd,=,LoggedRemoteCommand("git",,self.args)
self.startCommand(cmd)
class,Arch(Source):
"""Check,out,a,source,tree,from,an,Arch,repository,named,'archive'
available,at,'url'.,'version',specifies,which,version,number,(development
line),will,be,used,for,the,checkout:,this,is,mostly,equivalent,to,a
branch,name.,This,version,uses,the,'tla',tool,to,do,the,checkout,,to,use
'baz',see,L{Bazaar},instead.
"""
name,=,"arch"
#,TODO:,slaves,>0.6.6,will,accept,args['build-config'],,so,use,it
def,__init__(self,,url,,version,,archive=None,,**kwargs):
"""
@type,,url:,string
@param,url:,the,Arch,coordinates,of,the,repository.,This,is
typically,an,http://,URL,,but,could,also,be,the,absolute
pathname,of,a,local,directory,instead.
@type,,version:,string
@param,version:,the,category--branch--version,to,check,out.,This,is
the,default,branch.,If,a,build,specifies,a,different
branch,,it,will,be,used,instead,of,this.
@type,,archive:,string
@param,archive:,The,archive,name.,If,provided,,it,must,match,the,one
that,comes,from,the,repository.,If,not,,the
repository's,default,will,be,used.
"""
self.branch,=,version
Source.__init__(self,,**kwargs)
self.addFactoryArguments(url=url,
version=version,
archive=archive,
)
self.args.update({'url':,url,
'archive':,archive,
})
def,computeSourceRevision(self,,changes):
#,in,Arch,,fully-qualified,revision,numbers,look,like:
#,,arch@buildbot.sourceforge.net--2004/buildbot--dev--0--patch-104
#,For,any,given,builder,,all,of,this,is,fixed,except,the,patch-104.
#,The,Change,might,have,any,part,of,the,fully-qualified,string,,so,we
#,just,look,for,the,last,part.,We,return,the,"patch-NN",string.
if,not,changes:
return,None
lastChange,=,None
for,c,in,changes:
if,not,c.revision:
continue
if,c.revision.endswith("--base-0"):
rev,=,0
else:
i,=,c.revision.rindex("patch")
rev,=,int(c.revision[i+len("patch-"):])
lastChange,=,max(lastChange,,rev)
if,lastChange,is,None:
return,None
if,lastChange,==,0:
return,"base-0"
return,"patch-%d",%,lastChange
def,checkSlaveVersion(self,,cmd,,branch):
warnings,=,[]
slavever,=,self.slaveVersion(cmd)
if,not,slavever:
m,=,"slave,is,too,old,,does,not,know,about,%s",%,cmd
raise,BuildSlaveTooOldError(m)
#,slave,1.28,and,later,understand,'revision'
if,self.slaveVersionIsOlderThan(cmd,,"1.28"):
if,not,self.alwaysUseLatest:
#,we,don't,know,whether,our,requested,revision,is,the,latest
#,or,not.,If,the,tree,does,not,change,very,quickly,,this,will
#,probably,build,the,right,thing,,so,emit,a,warning,rather
#,than,refuse,to,build,at,all
m,=,"WARNING,,buildslave,is,too,old,to,use,a,revision"
log.msg(m)
warnings.append(m,+,"\n")
if,self.slaveVersionIsOlderThan(cmd,,"1.39"):
#,the,slave,doesn't,know,to,avoid,re-using,the,same,sourcedir
#,when,the,branch,changes.,We,have,no,way,of,knowing,which,branch
#,the,last,build,used,,so,if,we're,using,a,non-default,branch,and
#,either,'update',or,'copy',modes,,it,is,safer,to,refuse,to
#,build,,and,tell,the,user,they,need,to,upgrade,the,buildslave.
if,(branch,!=,self.branch
and,self.args['mode'],in,("update",,"copy")):
m,=,("This,buildslave,(%s),does,not,know,about,multiple,"
"branches,,and,using,mode=%s,would,probably,build,the,"
"wrong,tree.,"
"Refusing,to,build.,Please,upgrade,the,buildslave,to,"
"buildbot-0.7.0,or,newer.",%,(self.build.slavename,
self.args['mode']))
log.msg(m)
raise,BuildSlaveTooOldError(m)
return,warnings
def,startVC(self,,branch,,revision,,patch):
self.args['version'],=,branch
self.args['revision'],=,revision
self.args['patch'],=,patch
warnings,=,self.checkSlaveVersion("arch",,branch)
revstuff,=,[]
if,branch,is,not,None,and,branch,!=,self.branch:
revstuff.append("[branch]")
if,revision,is,not,None:
revstuff.append("patch%s",%,revision)
self.description.extend(revstuff)
self.descriptionDone.extend(revstuff)
cmd,=,LoggedRemoteCommand("arch",,self.args)
self.startCommand(cmd,,warnings)
class,Bazaar(Arch):
"""Bazaar,is,an,alternative,client,for,Arch,repositories.,baz,is,mostly
compatible,with,tla,,but,archive,registration,is,slightly,different."""
#,TODO:,slaves,>0.6.6,will,accept,args['build-config'],,so,use,it
def,__init__(self,,url,,version,,archive,,**kwargs):
"""
@type,,url:,string
@param,url:,the,Arch,coordinates,of,the,repository.,This,is
typically,an,http://,URL,,but,could,also,be,the,absolute
pathname,of,a,local,directory,instead.
@type,,version:,string
@param,version:,the,category--branch--version,to,check,out
@type,,archive:,string
@param,archive:,The,archive,name,(required).,This,must,always,match
the,one,that,comes,from,the,repository,,otherwise,the
buildslave,will,attempt,to,get,sources,from,the,wrong
archive.
"""
self.branch,=,version
Source.__init__(self,,**kwargs)
self.addFactoryArguments(url=url,
version=version,
archive=archive,
)
self.args.update({'url':,url,
'archive':,archive,
})
def,startVC(self,,branch,,revision,,patch):
self.args['version'],=,branch
self.args['revision'],=,revision
self.args['patch'],=,patch
warnings,=,self.checkSlaveVersion("bazaar",,branch)
revstuff,=,[]
if,branch,is,not,None,and,branch,!=,self.branch:
revstuff.append("[branch]")
if,revision,is,not,None:
revstuff.append("patch%s",%,revision)
self.description.extend(revstuff)
self.descriptionDone.extend(revstuff)
cmd,=,LoggedRemoteCommand("bazaar",,self.args)
self.startCommand(cmd,,warnings)
class,Bzr(Source):
"""Check,out,a,source,tree,from,a,bzr,(Bazaar),repository,at,'repourl'.
"""
name,=,"bzr"
def,__init__(self,,repourl=None,,baseURL=None,,defaultBranch=None,
**kwargs):
"""
@type,,repourl:,string
@param,repourl:,the,URL,which,points,at,the,bzr,repository.,This
is,used,as,the,default,branch.,Using,C{repourl},does
not,enable,builds,of,alternate,branches:,use
C{baseURL},to,enable,this.,Use,either,C{repourl},or
C{baseURL},,not,both.
@param,baseURL:,if,branches,are,enabled,,this,is,the,base,URL,to
which,a,branch,name,will,be,appended.,It,should
probably,end,in,a,slash.,Use,exactly,one,of
C{repourl},and,C{baseURL}.
@param,defaultBranch:,if,branches,are,enabled,,this,is,the,branch
to,use,if,the,Build,does,not,specify,one
explicitly.,It,will,simply,be,appended,to
C{baseURL},and,the,result,handed,to,the
'bzr,checkout,pull',command.
"""
self.repourl,=,repourl
self.baseURL,=,baseURL
self.branch,=,defaultBranch
Source.__init__(self,,**kwargs)
self.addFactoryArguments(repourl=repourl,
baseURL=baseURL,
defaultBranch=defaultBranch,
)
if,(not,repourl,and,not,baseURL),or,(repourl,and,baseURL):
raise,ValueError("you,must,provide,exactly,one,of,repourl,and"
",baseURL")
def,computeSourceRevision(self,,changes):
if,not,changes:
return,None
lastChange,=,max([int(c.revision),for,c,in,changes])
return,lastChange
def,startVC(self,,branch,,revision,,patch):
slavever,=,self.slaveVersion("bzr")
if,not,slavever:
m,=,"slave,is,too,old,,does,not,know,about,bzr"
raise,BuildSlaveTooOldError(m)
if,self.repourl:
assert,not,branch,#,we,need,baseURL=,to,use,branches
self.args['repourl'],=,self.repourl
else:
self.args['repourl'],=,self.baseURL,+,branch
self.args['revision'],=,revision
self.args['patch'],=,patch
revstuff,=,[]
if,branch,is,not,None,and,branch,!=,self.branch:
revstuff.append("[branch]")
self.description.extend(revstuff)
self.descriptionDone.extend(revstuff)
cmd,=,LoggedRemoteCommand("bzr",,self.args)
self.startCommand(cmd)
class,Mercurial(Source):
"""Check,out,a,source,tree,from,a,mercurial,repository,'repourl'."""
name,=,"hg"
def,__init__(self,,repourl=None,,baseURL=None,,defaultBranch=None,
branchType='dirname',,**kwargs):
"""
@type,,repourl:,string
@param,repourl:,the,URL,which,points,at,the,Mercurial,repository.
This,uses,the,'default',branch,unless,defaultBranch,is
specified,below,and,the,C{branchType},is,set,to
'inrepo'.,,It,is,an,error,to,specify,a,branch,without
setting,the,C{branchType},to,'inrepo'.
@param,baseURL:,if,'dirname',branches,are,enabled,,this,is,the,base,URL
to,which,a,branch,name,will,be,appended.,It,should
probably,end,in,a,slash.,,Use,exactly,one,of,C{repourl}
and,C{baseURL}.
@param,defaultBranch:,if,branches,are,enabled,,this,is,the,branch
to,use,if,the,Build,does,not,specify,one
explicitly.
For,'dirname',branches,,It,will,simply,be
appended,to,C{baseURL},and,the,result,handed,to
the,'hg,update',command.
For,'inrepo',branches,,this,specifies,the,named
revision,to,which,the,tree,will,update,after,a
clone.
@param,branchType:,either,'dirname',or,'inrepo',depending,on,whether
the,branch,name,should,be,appended,to,the,C{baseURL}
or,the,branch,is,a,mercurial,named,branch,and,can,be
found,within,the,C{repourl}
"""
self.repourl,=,repourl
self.baseURL,=,baseURL
self.branch,=,defaultBranch
self.branchType,=,branchType
Source.__init__(self,,**kwargs)
self.addFactoryArguments(repourl=repourl,
baseURL=baseURL,
defaultBranch=defaultBranch,
branchType=branchType,
)
if,(not,repourl,and,not,baseURL),or,(repourl,and,baseURL):
raise,ValueError("you,must,provide,exactly,one,of,repourl,and"
",baseURL")
def,startVC(self,,branch,,revision,,patch):
slavever,=,self.slaveVersion("hg")
if,not,slavever:
raise,BuildSlaveTooOldError("slave,is,too,old,,does,not,know,"
"about,hg")
if,self.repourl:
#,we,need,baseURL=,to,use,dirname,branches
assert,self.branchType,==,'inrepo',or,not,branch
self.args['repourl'],=,self.repourl
if,branch:
self.args['branch'],=,branch
else:
self.args['repourl'],=,self.baseURL,+,(branch,or,'')
self.args['revision'],=,revision
self.args['patch'],=,patch
revstuff,=,[]
if,branch,is,not,None,and,branch,!=,self.branch:
revstuff.append("[branch]")
self.description.extend(revstuff)
self.descriptionDone.extend(revstuff)
cmd,=,LoggedRemoteCommand("hg",,self.args)
self.startCommand(cmd)
def,computeSourceRevision(self,,changes):
if,not,changes:
return,None
#,without,knowing,the,revision,ancestry,graph,,we,can't,sort,the
#,changes,at,all.,So,for,now,,assume,they,were,given,to,us,in,sorted
#,order,,and,just,pay,attention,to,the,last,one.,See,ticket,#103,for
#,more,details.
if,len(changes),>,1:
log.msg("Mercurial.computeSourceRevision:,warning:,"
"there,are,%d,changes,here,,assuming,the,last,one,is,"
"the,most,recent",%,len(changes))
return,changes[-1].revision
class,P4(Source):
""",P4,is,a,class,for,accessing,perforce,revision,control"""
name,=,"p4"
def,__init__(self,,p4base,,defaultBranch=None,,p4port=None,,p4user=None,
p4passwd=None,,p4extra_views=[],
p4client='buildbot_%(slave)s_%(builder)s',,**kwargs):
"""
@type,,p4base:,string
@param,p4base:,A,view,into,a,perforce,depot,,typically
"//depot/proj/"
@type,,defaultBranch:,string
@param,defaultBranch:,Identify,a,branch,to,build,by,default.,Perforce
is,a,view,based,branching,system.,So,,the,branch
is,normally,the,name,after,the,base.,For,example,
branch=1.0,is,view=//depot/proj/1.0/...
branch=1.1,is,view=//depot/proj/1.1/...
@type,,p4port:,string
@param,p4port:,Specify,the,perforce,server,to,connection,in,the,format
<host>:<port>.,Example,"perforce.example.com:1666"
@type,,p4user:,string
@param,p4user:,The,perforce,user,to,run,the,command,as.
@type,,p4passwd:,string
@param,p4passwd:,The,password,for,the,perforce,user.
@type,,p4extra_views:,list,of,tuples
@param,p4extra_views:,Extra,views,to,be,added,to
the,client,that,is,being,used.
@type,,p4client:,string
@param,p4client:,The,perforce,client,to,use,for,this,buildslave.
"""
self.branch,=,defaultBranch
Source.__init__(self,,**kwargs)
self.addFactoryArguments(p4base=p4base,
defaultBranch=defaultBranch,
p4port=p4port,
p4user=p4user,
p4passwd=p4passwd,
p4extra_views=p4extra_views,
p4client=p4client,
)
self.args['p4port'],=,p4port
self.args['p4user'],=,p4user
self.args['p4passwd'],=,p4passwd
self.args['p4base'],=,p4base
self.args['p4extra_views'],=,p4extra_views
self.p4client,=,p4client
def,setBuild(self,,build):
Source.setBuild(self,,build)
self.args['p4client'],=,self.p4client,%,{
'slave':,build.slavename,
'builder':,build.builder.name,
}
def,computeSourceRevision(self,,changes):
if,not,changes:
return,None
lastChange,=,max([int(c.revision),for,c,in,changes])
return,lastChange
def,startVC(self,,branch,,revision,,patch):
slavever,=,self.slaveVersion("p4")
assert,slavever,,"slave,is,too,old,,does,not,know,about,p4"
args,=,dict(self.args)
args['branch'],=,branch,or,self.branch
args['revision'],=,revision
args['patch'],=,patch
cmd,=,LoggedRemoteCommand("p4",,args)
self.startCommand(cmd)
class,P4Sync(Source):
"""This,is,a,partial,solution,for,using,a,P4,source,repository.,You,are
required,to,manually,set,up,each,build,slave,with,a,useful,P4
environment,,which,means,setting,various,per-slave,environment,variables,
and,creating,a,P4,client,specification,which,maps,the,right,files,into
the,slave's,working,directory.,Once,you,have,done,that,,this,step,merely
performs,a,'p4,sync',to,update,that,workspace,with,the,newest,files.
Each,slave,needs,the,following,environment:
-,PATH:,the,'p4',binary,must,be,on,the,slave's,PATH
-,P4USER:,each,slave,needs,a,distinct,user,account
-,P4CLIENT:,each,slave,needs,a,distinct,client,specification
You,should,use,'p4,client',(?),to,set,up,a,client,view,spec,which,maps
the,desired,files,into,$SLAVEBASE/$BUILDERBASE/source,.
"""
name,=,"p4sync"
def,__init__(self,,p4port,,p4user,,p4passwd,,p4client,,**kwargs):
assert,kwargs['mode'],==,"copy",,"P4Sync,can,only,be,used,in,mode=copy"
self.branch,=,None
Source.__init__(self,,**kwargs)
self.addFactoryArguments(p4port=p4port,
p4user=p4user,
p4passwd=p4passwd,
p4client=p4client,
)
self.args['p4port'],=,p4port
self.args['p4user'],=,p4user
self.args['p4passwd'],=,p4passwd
self.args['p4client'],=,p4client
def,computeSourceRevision(self,,changes):
if,not,changes:
return,None
lastChange,=,max([int(c.revision),for,c,in,changes])
return,lastChange
def,startVC(self,,branch,,revision,,patch):
slavever,=,self.slaveVersion("p4sync")
assert,slavever,,"slave,is,too,old,,does,not,know,about,p4"
cmd,=,LoggedRemoteCommand("p4sync",,self.args)
self.startCommand(cmd)
class,Monotone(Source):
"""Check,out,a,revision,from,a,monotone,server,at,'server_addr',
branch,'branch'.,,'revision',specifies,which,revision,id,to,check
out.
This,step,will,first,create,a,local,database,,if,necessary,,and,then,pull
the,contents,of,the,server,into,the,database.,,Then,it,will,do,the
checkout/update,from,this,database."""
name,=,"monotone"
def,__init__(self,,server_addr,,branch,,db_path="monotone.db",
monotone="monotone",
**kwargs):
Source.__init__(self,,**kwargs)
self.addFactoryArguments(server_addr=server_addr,
branch=branch,
db_path=db_path,
monotone=monotone,
)
self.args.update({"server_addr":,server_addr,
"branch":,branch,
"db_path":,db_path,
"monotone":,monotone})
def,computeSourceRevision(self,,changes):
if,not,changes:
return,None
return,changes[-1].revision
def,startVC(self):
slavever,=,self.slaveVersion("monotone")
assert,slavever,,"slave,is,too,old,,does,not,know,about,monotone"
cmd,=,LoggedRemoteCommand("monotone",,self.args)
self.startCommand(cmd)
#,-*-,Mode:,Python,;,indent-tabs-mode:,nil,-*-
#,This,Source,Code,Form,is,subject,to,the,terms,of,the,Mozilla,Public
#,License,,v.,2.0.,If,a,copy,of,the,MPL,was,not,distributed,with,this
#,file,,You,can,obtain,one,at,http://mozilla.org/MPL/2.0/.
from,zope.interface,import,implements
from,twisted.internet,import,reactor
from,twisted.application,import,service,,internet,,strports
from,twisted.python,import,log,,runtime
from,twisted.protocols,import,basic
from,twisted.cred,import,portal,,checkers
from,twisted.spread,import,pb
from,buildbot,import,interfaces,,buildset,,util,,pbutil
from,buildbot.status,import,builder
from,buildbot.sourcestamp,import,SourceStamp
from,buildbot.changes.maildir,import,MaildirService
from,buildbot.process.properties,import,Properties
from,buildbot,import,scheduler
class,Scheduler(scheduler.Scheduler):
'''The,buildbot.scheduler.Scheduler,class,is,sublclassed,(with,the,same,name,to,not,have,
to,modify,any,of,the,master.cfg,code),from,the,original,source,to,add,the,ability,to,
handle,buildsets'''
def,addChange(self,,change):
if,self.branch,is,not,None,and,change.branch,not,in,self.branch:
log.msg("%s,ignoring,off-branch,%s",%,(self,,change))
return
if,self.categories,is,not,None,and,change.category,not,in,self.categories:
log.msg("%s,ignoring,non-matching,categories,%s",%,(self,,change))
return
if,not,self.fileIsImportant:
self.addImportantChange(change)
elif,self.fileIsImportant(change):
self.addImportantChange(change)
else:
self.addUnimportantChange(change)
def,fireTimer(self):
#,clear,out,our,state
self.timer,=,None
self.nextBuildTime,=,None
#,Only,build,changes,that,are,deemed,important,by,self.fileIsImportant
changes,=,self.importantChanges
self.importantChanges,=,[]
self.unimportantChanges,=,[]
#,Only,add,builders,to,the,buildset,that,are,currently,online
buildset_builderNames,=,[]
for,builder_name,in,self.builderNames:
#,Get,a,builder,from,the,BotMaster:
try:
builder,=,self.parent.botmaster.builders.get(builder_name)
except,AttributeError:
#,when,this,scheduler,is,used,by,the,AnyBranchScheduler,,botmaster,is,one,level,up,from,normal
builder,=,self.parent.parent.botmaster.builders.get(builder_name)
if,builder.builder_status.getState()[0],==,'idle':
buildset_builderNames.append(builder_name)
#,create,a,BuildSet,,submit,it,to,the,BuildMaster
bs,=,buildset.BuildSet(buildset_builderNames,
SourceStamp(changes=changes),
properties=self.properties)
self.submitBuildSet(bs)
class,PhaseTwoScheduler(Scheduler):
changeDir,=,""
def,__init__(self,,name,,branch,,treeStableTimer,,builderNames,
fileIsImportant=None,,properties={},,categories=None,,builderDependencies=[],,changeDir=".",,priorities=[]):
'''
priorities,:,list,of,(branch,,priorities),tuples,that,map,branches,to
priorities,(int)
'''
Scheduler.__init__(self,,name,,branch,,treeStableTimer,,builderNames,,
fileIsImportant,,properties,,categories)
#,-,each,builder,must,have,a,dependent,that,is,in,the,upstream,builder
#,-,multiple,builders,can,be,dependent,on,the,same,upstream,builder
self.builderDependencies,=,builderDependencies
self.changeDir,=,changeDir
self.priorities,=,priorities
def,fireTimer(self):
#,clear,out,our,state
self.timer,=,None
self.nextBuildTime,=,None
changes,=,self.unimportantChanges,+,self.importantChanges
self.importantChanges,=,[]
self.unimportantChanges,=,[]
buildset_builderNames,=,[]
#,There,may,be,multiple,build,requests,,only,process,the,very,last,one,(latest)
change,=,changes[-1]
#,Only,add,builders,that,are:
#,,,,1),dependent,builder,is,listed,in,the,change,request,,this,means,that,the,upstream,builder,was,online
#,,,,2),builder,is,online
#,determine,the,priority,based,on,branch
#,note,that,this,is,a,list,comprehension,,so,we,need,to,"unpack",with
#,[0],at,end
priority,=,[p[1],for,p,in,self.priorities,if,p[0],==,change.branch][0]
f,=,open("%s/change-%s.%s",%,(self.changeDir,,change.revision,,priority))
phase1Builders,=,[]
for,line,in,f.readlines():
if,line.startswith("builders:"):
phase1Builders,=,line[line.find(":")+1:].strip().split()
break
#,builders,is,a,list,of,builders,that,built,the,request,in,Phase1
for,p1Builder,in,phase1Builders:
#,Get,the,depenent,builder
for,dependent,in,self.builderDependencies:
if,p1Builder,==,dependent[1]:
p2Builder,=,dependent[0]
#,See,if,the,builder,is,online
#,Get,a,builder,from,the,BotMaster:
builder,=,self.parent.botmaster.builders.get(p2Builder)
#,Add,the,builder,to,the,set,if,it,is,idle,(not,building,and,not,offline)
if,builder.builder_status.getState()[0],==,'idle':
buildset_builderNames.append(p2Builder)
#,create,a,BuildSet,,submit,it,to,the,BuildMaster
bs,=,buildset.BuildSet(buildset_builderNames,
SourceStamp(changes=changes),
properties=self.properties)
self.submitBuildSet(bs)
class,AnyBranchScheduler(scheduler.AnyBranchScheduler):
'''The,buildbot.scheduler.AnyBranchScheduler,is,subclassed,to,use,our,modified
Scheduler,(above),with,the,buildsets,additions'''
schedulerFactory,=,Scheduler
class,BuilderDependent(scheduler.Dependent):
"""This,scheduler,runs,some,set,of,'downstream',builds,when,the
'upstream',scheduler,has,completed,successfully."""
fileIsImportant,=,None
def,__init__(self,,name,,upstream,,callbackInterval,,builderNames,,builderDependencies,,
properties={},,fileIsImportant=None):
scheduler.Dependent.__init__(self,,name,,upstream,,builderNames,,properties)
#,-,each,builder,must,have,a,dependent,that,is,in,the,upstream,builder
#,-,multiple,builders,can,be,dependent,on,the,same,upstream,builder
self.builderDependencies,=,builderDependencies
self.callbackInterval,=,callbackInterval
#,TODO:,self.upstream,is,set,to,None,upon,init,in,Dependent,...,not,sure,why,,so,this,is,a,workaround
#,see,http://github.com/djmitche/buildbot/commit/4066acfdd6477e59b00767c1c5607e4666e15d6d
self.upstream,=,upstream
if,fileIsImportant:
assert,callable(fileIsImportant)
self.fileIsImportant,=,fileIsImportant
for,builder_name,in,self.builderNames:
dependent_builder,=,''
#,Get,the,depenent,builder
for,dependent,in,self.builderDependencies:
if,builder_name,==,dependent[0]:
dependent_builder,=,dependent[1]
break
#,Make,sure,there,is,a,defined,dependent,builder
if,dependent_builder,==,'':
errmsg,=,"The,builder,%s,has,no,corresponding,dependent,builder",%,builder_name
assert,False,,errmsg
#,Make,sure,that,the,dependent,builder,is,defined,in,the,upstream,scheduler
if,dependent_builder,not,in,self.upstream.listBuilderNames():
#if,dependent_builder,not,in,self.findUpstreamScheduler().listBuilderNames():
errmsg,=,"The,dependent,builder,%s,is,not,defined,in,the,upstream,scheduler,%s",%,(dependent_builder,,self.upstream.name)
assert,False,,errmsg
self.timer,=,None
self.source_stamp,=,None
def,upstreamBuilt(self,,ss):
#,Only,add,builders,to,the,buildset,that,are,currently,online,and,if,the,dependent,builder,
#,also,built,this,change.
#,If,a,fileIsImportant,function,is,defined,,check,the,files,before,determining,buildsets
if,self.fileIsImportant:
startThisBuildSet,=,False
#,SourceStamp,provides,us,with,a,tuple,of,changes,,loop,through,and,check,them,all
for,change,in,ss.changes:
if,self.fileIsImportant(change):
#,If,any,file,is,important,,we,start,the,buildSet
startThisBuildSet,=,True
break
if,not,startThisBuildSet:
#,no,important,files,found,,do,not,continue,with,this,buildset
return
if,self.source_stamp,==,None:
#,This,is,the,first,time,that,the,ss,has,been,seen,,this,is,NOT,a,callback
self.source_stamp,=,ss
else:
#,This,can,either,be,a,callback,or,a,new,ss,passed,in,from,upstream,builder
try:
revision_prev,=,int(self.source_stamp.revision)
revision_curr,=,int(ss.revision)
except,ValueError:
errmsg,=,"BuilderDependent.upstreamBuilt,has,an,unknown,ss.revison:,%s",%,(ss.revision)
assert,False,,errmsg
#,ss.revision,is,an,OLDER,REV,than,self.source_stamp.revision
if,revision_curr,<,revision_prev:,
#,This,means,we,are,a,callback,,and,during,sleep,period,a,new,build,request,
#,has,come,in,and,is,now,in,control,,we,can,just,stop,running.
return
#,ss.revision,is,a,NEWER,REV,than,self.source_stamp.revision
elif,revision_curr,>,revision_prev:
#,This,would,indicate,a,new,build,and,we,need,to,merge,ss,and,self.source_stamp
ss.mergeWith([self.source_stamp])
self.source_stamp,=,ss
#,Revisions,are,the,same,so,this,is,the,callback
#,else,revision_curr,==,revision_prev
buildset_builderNames,=,[]
for,builder_name,in,self.builderNames:
#,Get,the,depenent,builder
for,dependent,in,self.builderDependencies:
if,builder_name,==,dependent[0]:
dependent_builder,=,dependent[1]
break
#,Get,the,dependent,builder
dep_builder,=,self.parent.getStatus().getBuilder(dependent_builder)
#,Determine,the,revision,of,the,last,build,for,the,dependent,builder
#,need,to,make,sure,that,the,builder,has,at,least,one,previous,build
try:
dep_ss,=,dep_builder.getLastFinishedBuild().getSourceStamp()
except,AttributeError:
dep_ss,=,SourceStamp()
#,Only,continue,the,check,if,the,dependent,builder,built,the,sourceStamp,,
if,ss.revision,==,dep_ss.revision:
#,Get,a,builder,from,the,BotMaster:
builder,=,self.parent.botmaster.builders.get(builder_name)
if,builder.builder_status.getState()[0],==,'building':
#,There,is,a,builder,in,this,scheduler,that,is,active,so,we,need
#,to,NOT,start,the,build,yet,,but,instead,callback,in,X,seconds
#,to,see,if,all,of,the,builders,are,available.
self.timer,=,reactor.callLater(self.callbackInterval,,self.upstreamBuilt,,ss)
return
#,Add,the,builder,to,the,set,if,it,is,idle,(not,building,and,not,offline)
if,builder.builder_status.getState()[0],==,'idle':
buildset_builderNames.append(builder_name)
bs,=,buildset.BuildSet(buildset_builderNames,,ss,
properties=self.properties)
self.submitBuildSet(bs)
#,Clear,the,tracked,source,stamp
self.source_stamp,=,None
#,This,Source,Code,Form,is,subject,to,the,terms,of,the,Mozilla,Public
#,License,,v.,2.0.,If,a,copy,of,the,MPL,was,not,distributed,with,this
#,file,,You,can,obtain,one,at,http://mozilla.org/MPL/2.0/.
version,=,"0.7.10p1"
#,This,Source,Code,Form,is,subject,to,the,terms,of,the,Mozilla,Public
#,License,,v.,2.0.,If,a,copy,of,the,MPL,was,not,distributed,with,this
#,file,,You,can,obtain,one,at,http://mozilla.org/MPL/2.0/.
import,re
from,email.Message,import,Message
from,email.Utils,import,formatdate
from,email.MIMEText,import,MIMEText
try:
from,email.MIMEMultipart,import,MIMEMultipart
canDoAttachments,=,True
except,ImportError:
canDoAttachments,=,False
import,urllib
import,string
import,os
from,cPickle,import,load,,dump
from,zope.interface,import,implements
from,twisted.internet,import,defer
from,twisted.mail.smtp,import,sendmail
from,twisted.python,import,log,as,twlog
from,buildbot,import,interfaces,,util
from,buildbot.status,import,base
from,buildbot.status.builder,import,FAILURE,,SUCCESS,,WARNINGS
from,buildbot.status.mail,import,MailNotifier
class,BuilderGroup():
def,__init__(self):
self.builderNames,=,[]
self.currentBuild,=,0
self.sent,=,0
self.cachedMessages,=,[]
def,cacheMessage(self,,name,,build,,results):
self.cachedMessages.append({'name':name,,'build':build,,'results':results})
def,reset(self):
#,reset,all,values
self.cachedMessages,=,[]
self.sent,=,0
self.currentBuild,=,0
def,addBuilderNames(self,,names):
if,isinstance(names,,list):
self.builderNames.extend(names)
else:
self.builderNames.append(names)
def,containsBuilder(self,,name):
if,name,in,self.builderNames:
return,True
else:
return,False
class,AggregateMailNotifier(MailNotifier):
'''
The,AggregateMailNotifier,extends,MailNotifier,to,add,support,for,emails,to,be,batched,together
into,single,emails,that,only,fire,once,a,scheduler,group,of,builders,is,finished,building.
'''
#,compare_attrs,is,used,to,compare,two,instances,of,the,same,class,-,the,attributes,in,this,list,are,compared,to,each
#,other,to,determine,if,it,is,the,same,class,object
compare_attrs,=,MailNotifier.compare_attrs,+,['schedulerGroupsSendFirst',,'schedulerGroups']
def,__init__(self,,fromaddr,,mode="all",,categories=None,,builders=None,
addLogs=False,,relayhost="localhost",
subject="",
lookup=None,,extraRecipients=[],
sendToInterestedUsers=True,
schedulerGroups,=,[],
schedulerGroupsSendFirst,=,1
):
'''
@type,,schedulerGroupsSendFirst:,int
@param,schedulerGroupsSendFirst:,How,many,mails,to,send,to,interested,users,before,we
group,the,rest,of,the,emails.
@type,,schedulerGroups:,list,(can,be,list,of,lists)
@param,schedulerGroups:,list,of,schedulers,to,group,emails,by.,,Multiple,schedulers,can
be,grouped,together,by,passing,them,in,as,a,list.,,This,may,be,a
list,of,lists,,but,can,not,be,nested,beyond,that.
'''
self.schedulerGroupsSendFirst,=,schedulerGroupsSendFirst
#,builderGroups,is,a,list,BuilderGroups
self.builderGroups,=,[]
for,schedulerGroup,in,schedulerGroups:
group,=,BuilderGroup()
if,isinstance(schedulerGroup,,list):,,,,
for,scheduler,in,schedulerGroup:
group.addBuilderNames(scheduler.listBuilderNames())
else:
group.addBuilderNames(schedulerGroup.listBuilderNames())
self.builderGroups.append(group)
MailNotifier.__init__(self,,fromaddr,,mode,,categories,,builders,
addLogs,,relayhost,
subject,
lookup,,extraRecipients,
sendToInterestedUsers)
def,shouldSendMessage(self,,name,,build,,results):
#,Based,on,name,,build,,results,-,should,a,message,be,sent?,Boolean,return,value.
if,self.builders,is,not,None,and,name,not,in,self.builders:
return,False
if,self.categories,is,not,None,and,\
builder.category,not,in,self.categories:
return,False
if,self.mode,==,"failing",and,results,!=,FAILURE:
return,False
if,self.mode,==,"passing",and,results,!=,SUCCESS:
return,False
if,self.mode,==,"problem":
if,results,!=,FAILURE:
return,False
prev,=,build.getPreviousBuild()
if,prev,and,prev.getResults(),==,FAILURE:
return,False
return,True
def,buildFinished(self,,name,,build,,results):
#,Called,every,time,a,machine,finishes,a,phase
if,self.builderGroups:
currentBuilder,=,build.getBuilder()
currentBuilderName,=,currentBuilder.getName()
revision,=,build.getSourceStamp().revision
for,builderGroup,in,self.builderGroups:
if,builderGroup.containsBuilder(currentBuilderName):
if,builderGroup.currentBuild,==,revision:
if,self.shouldSendMessage(name,,build,,results):
#,Append,to,cache
builderGroup.cacheMessage(name,,build,,results)
if,self.schedulerGroupsSendFirst:
if,builderGroup.sent,<,self.schedulerGroupsSendFirst:
builderGroup.sent,+=,1
MailNotifier.buildFinished(self,,name,,build,,results)
elif,builderGroup.currentBuild,!=,revision:
#,new,revision,-,reset,BuilderGroup,just,in,case
builderGroup.reset()
builderGroup.currentBuild,=,revision
if,self.shouldSendMessage(name,,build,,results):
#,Append,to,cache
builderGroup.cacheMessage(name,,build,,results)
if,self.schedulerGroupsSendFirst:
builderGroup.sent,=,1
#,send,this,email,out
return,MailNotifier.buildFinished(self,,name,,build,,results)
#,Are,there,any,builders,left?,if,not,send,the,grouped,message
for,builder,in,builderGroup.builderNames:
#,The,current,builder,will,always,have,a,building,state,
#,so,do,not,check,state,if,current,builder
if,builder,!=,currentBuilderName:
state,=,self.status.getBuilder(builder).getState()[0]
if,state,==,"building":,,,,,#,if,any,are,building,we,can,return
return
#,Nothing,is,building,-,send,out,the,aggregated,message
if,len(builderGroup.cachedMessages),==,builderGroup.sent:
#,We've,already,sent,out,all,the,messages,in,the,cache
#,so,there,is,no,need,to,send,out,the,aggregated,messages
return
#,Note,that,this,code,will,only,get,run,if,the,two,conditions,above,are,not,met,(both,return,nothing)
d,=,self.sendAggregateMail(builderGroup.cachedMessages)
builderGroup.reset()
return,d
else:,,,#,send,message,like,regular,MailNotifier
#,this,comment,copied,from,MailNotifier:
#,for,testing,purposes,,buildMessage,returns,a,Deferred,that,fires
#,when,the,mail,has,been,sent.,To,help,unit,tests,,we,return,that
#,Deferred,here,even,though,the,normal,IStatusReceiver.buildFinished
#,signature,doesn't,do,anything,with,it.,If,that,changes,(if
#,.buildFinished's,return,value,becomes,significant),,we,need,to
#,rearrange,this.
return,MailNotifier.buildFinished(self,,name,,build,,results)
def,sendAggregateMail(self,,cachedResults):
#,override,this,function
#,cachedMessages,is,a,list,of,dicts:,{'name':name,,'build':build,,'results':results}
pass#,-*-,test-case-name:,buildbot.test.test_status,-*-
#,This,Source,Code,Form,is,subject,to,the,terms,of,the,Mozilla,Public
#,License,,v.,2.0.,If,a,copy,of,the,MPL,was,not,distributed,with,this
#,file,,You,can,obtain,one,at,http://mozilla.org/MPL/2.0/.
from,twisted.spread,import,pb
from,twisted.python,import,components,,log,as,twlog
from,twisted.internet,import,reactor
from,twisted.application,import,strports
from,twisted.cred,import,portal,,checkers
from,buildbot,import,interfaces
from,zope.interface,import,Interface,,implements
from,buildbot.status,import,builder,,base
from,buildbot.changes,import,changes
from,buildbot.status.client,import,IRemote
from,buildbot.status.client,import,StatusClientPerspective,as,SCP
#,TODO:,BuilderGroup,should,be,moved,out,of,aggregate...,someday
from,aggregateMailNotifier,import,BuilderGroup,as,BG
class,BuilderGroup(BG):
def,__init__(self):
BG.__init__(self)
self.failures,=,False
self.onlineslaves,=,[]
def,reset(self):
BG.reset(self)
self.failures,=,False
self.onlineslaves,=,[]
class,StatusClientPerspective(SCP):
passBuilderGroups,=,[]
def,setPassBuilderGroups(self,,passBuilderGroups):
self.passBuilderGroups,=,passBuilderGroups
def,getSourceStampDict(self,,build):
'''There,are,perspectivebroker,Unpersistable,issues,with,passing,the,build,object,
so,as,a,workaround,convert,to,a,plain,dictionary,and,pass,the,dictionary,object.
'''
d,=,{}
d['revision'],=,build.getSourceStamp().revision
d['branch'],=,build.getSourceStamp().branch
d['patch'],=,build.getSourceStamp().patch
d['number'],=,build.getNumber()
#,convert,the,changes,into,a,passable,object
authors,=,[]
revisions,=,[]
comments,=,[]
for,change,in,build.getSourceStamp().changes:
authors.append(change.getShortAuthor())
revisions.append(change.revision)
comments.append(change.comments)
d['authors'],=,authors
d['revisions'],=,revisions
d['comments'],=,comments
return,d
#,override,all,StatusClientPerspective,methods,that,pass,a,build,object
def,buildStarted(self,,name,,build):
self.client.callRemote("buildStarted",,name,,self.getSourceStampDict(build))
if,self.subscribed,in,("steps",,"logs",,"full"):
self.subscribed_to.append(build)
return,(self,,self.interval)
return,None
def,buildFinished(self,,name,,build,,results):
if,build,in,self.subscribed_to:
#,we,might,have,joined,during,the,build
self.subscribed_to.remove(build)
self.client.callRemote("buildFinished",
name,,self.getSourceStampDict(build),,results)
#,TODO:,most,of,this,code,is,copied,from,aggregateMailNotifier,...,need,to,consolidate,code
if,self.passBuilderGroups:
currentBuilder,=,build.getBuilder()
currentBuilderName,=,currentBuilder.getName()
revision,=,build.getSourceStamp().revision
for,builderGroup,in,self.passBuilderGroups:
if,builderGroup.containsBuilder(currentBuilderName):
#,if,this,is,the,first,run,,set,the,currentBuild,when,first,called
if,builderGroup.currentBuild,==,0:
builderGroup.currentBuild,=,revision
if,builderGroup.currentBuild,==,revision:
if,results,!=,0:
builderGroup.failures,=,True
#,Are,there,any,builders,left?
for,builder,in,builderGroup.builderNames:
#,The,current,builder,will,always,have,a,building,state,
#,so,do,not,check,state,if,current,builder
if,builder,!=,currentBuilderName:
state,=,self.status.getBuilder(builder).getState()[0]
if,state,==,"building":,,,,,#,if,any,are,building,we,can,return
return
#,Nothing,is,building,-,should,we,send,out,a,pass,notification?
if,not,builderGroup.failures:
self.client.callRemote("groupPass",,self.getSourceStampDict(build),)
builderGroup.reset()
return
else:,,,#,builderGroup.currentBuild,!=,revision
#,new,revision,-,reset,BuilderGroup,just,in,case
builderGroup.reset()
builderGroup.currentBuild,=,revision
break
#,mode,>=,steps
def,buildETAUpdate(self,,build,,eta):
self.client.callRemote("buildETAUpdate",
build.getBuilder().getName(),,self.getSourceStampDict(build),
eta)
def,stepStarted(self,,build,,step):
#,we,add,some,information,here,so,the,client,doesn't,have,to,do,an
#,extra,round-trip
self.client.callRemote("stepStarted",
build.getBuilder().getName(),,self.getSourceStampDict(build),
step.getName(),,IRemote(step))
if,self.subscribed,in,("logs",,"full"):
self.subscribed_to.append(step)
return,(self,,self.interval)
return,None
def,stepFinished(self,,build,,step,,results):
self.client.callRemote("stepFinished",
build.getBuilder().getName(),,self.getSourceStampDict(build),
step.getName(),,IRemote(step),
results)
if,step,in,self.subscribed_to:
#,eventually,(through,some,new,subscription,method),we,could
#,join,in,the,middle,of,the,step
self.subscribed_to.remove(step)
#,mode,>=,logs
def,stepETAUpdate(self,,build,,step,,ETA,,expectations):
self.client.callRemote("stepETAUpdate",
build.getBuilder().getName(),,self.getSourceStampDict(build),
step.getName(),,IRemote(step),
ETA,,expectations)
def,logStarted(self,,build,,step,,log):
#,TODO:,make,the,HTMLLog,adapter
rlog,=,IRemote(log,,None)
if,not,rlog:
print,"hey,,couldn't,adapt,%s,to,IRemote",%,log
self.client.callRemote("logStarted",
build.getBuilder().getName(),,self.getSourceStampDict(build),
step.getName(),,IRemote(step),
log.getName(),,IRemote(log,,None))
if,self.subscribed,in,("full",):
self.subscribed_to.append(log)
return,self
return,None
def,logFinished(self,,build,,step,,log):
self.client.callRemote("logFinished",
build.getBuilder().getName(),,self.getSourceStampDict(build),
step.getName(),,IRemote(step),
log.getName(),,IRemote(log,,None))
if,log,in,self.subscribed_to:
self.subscribed_to.remove(log)
#,mode,>=,full
def,logChunk(self,,build,,step,,log,,channel,,text):
self.client.callRemote("logChunk",
build.getBuilder().getName(),,self.getSourceStampDict(build),
step.getName(),,IRemote(step),
log.getName(),,IRemote(log),
channel,,text)
class,PBListener(base.StatusReceiverMultiService):
"""I,am,a,listener,for,PB-based,status,clients."""
compare_attrs,=,["port",,"cred"]
implements(portal.IRealm)
def,__init__(self,,port,,user="statusClient",,passwd="clientpw",,denotesPassSchedulerGroups=None):
'''
port,,,,:,port,for,PBListener,to,listen,on
user,,,,:,PBListener,username
passwd,,:,PBListener,password
denotesPassSchedulerGroups,:,list,of,scheduler,group(s),that,when,all,builders,pass,indicates,a,passing,build
'''
base.StatusReceiverMultiService.__init__(self)
if,type(port),is,int:
port,=,"tcp:%d",%,port
self.port,=,port
self.cred,=,(user,,passwd)
p,=,portal.Portal(self)
c,=,checkers.InMemoryUsernamePasswordDatabaseDontUse()
c.addUser(user,,passwd)
p.registerChecker(c)
f,=,pb.PBServerFactory(p)
#TODO:,not,sure,if,i,need,this:
f.unsafeTracebacks,=,True
self.passBuilderGroups,=,[]
if,denotesPassSchedulerGroups:
self.setupDenotesPassSchedulerGroup(denotesPassSchedulerGroups)
s,=,strports.service(port,,f)
s.setServiceParent(self)
def,setupDenotesPassSchedulerGroup(self,,schedulerGroups):
for,schedulerGroup,in,schedulerGroups:
group,=,BuilderGroup()
if,isinstance(schedulerGroup,,list):,,,,
for,scheduler,in,schedulerGroup:
group.addBuilderNames(scheduler.listBuilderNames())
else:
group.addBuilderNames(schedulerGroup.listBuilderNames())
self.passBuilderGroups.append(group)
def,setServiceParent(self,,parent):
base.StatusReceiverMultiService.setServiceParent(self,,parent)
self.setup()
def,setup(self):
self.status,=,self.parent.getStatus()
def,requestAvatar(self,,avatarID,,mind,,interface):
assert,interface,==,pb.IPerspective
p,=,StatusClientPerspective(self.status)
p.setPassBuilderGroups(self.passBuilderGroups)
p.attached(mind),#,perhaps,.callLater(0),?
return,(pb.IPerspective,,p,
lambda,p=p,mind=mind:,p.detached(mind))
class,PhaseOneListener(base.StatusReceiverMultiService):
compare_attrs,=,["denotesPassSchedulerGroups",,"changeDir",,"priorities"]
def,__init__(self,,denotesPassSchedulerGroups=None,,changeDir=None,,priorities=[]):
'''
